<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[Pyinstaller将python脚本打包成可执行文件]]></title>
      <url>%2F2017%2F04%2F14%2FPyinstaller%E5%B0%86python%E8%84%9A%E6%9C%AC%E6%89%93%E5%8C%85%E6%88%90%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6%2F</url>
      <content type="text"><![CDATA[PyInstaller可以用来打包Python应用程序，把Python脚本和所用到的库打包为exe文件，可以更方便的发布程序，避免使用程序的每个电脑都必须安装Python，这样，打包完的程序就可以在没有安装Python解释器的机器上运行了。 安装Pyinstaller使用pip或者easy_install来安装：sudo pip install pyinstaller 使用PyInstallerpyinstaller myapp.py 当使用PyInstaller打包的时候，默认生成一个文件夹，文件夹中包含所有依赖项，以及可执行文件。打包成文件夹的好处就是debug的时候可以清楚的看到依赖项有没有包含。另一个好处是更新的时候，只需要更新可执行文件就可以了。当然缺点也很明显，不方便，不易管理。 那么它是如何工作的呢？PyInstaller的引导程序是一个二进制可执行程序。当用户启动你的程序的时候，PyInstaller的引导程序开始运行，首先创建一个临时的Python环境，然后通过Python解释器导入程序的依赖，当然它们都在同一个文件夹下。 打包成一个文件我们可以用onefile参数将所有文件打包到一个可执行文件中。 pyinstaller --onefile myapp.py 打包成一个文件相对于文件夹更容易管理。坏处运行相对比较慢。这个文件中包含了压缩的依赖文件拷贝（.so文件-Linux，dll文件-Windows）。 当程序运行时，PyInstaller的引导程序会新建一个临时文件夹。然后解压程序的第三方依赖文件到临时文件夹中。这也是为什么一个可执行文件比文件夹中执行的时间要长的原因。剩下的就和上面的一样了。 总结所以，我们要通过PyInstaller生成可执行的文件主要下面两步。 pyinstaller [option] myapp.py option为空生成文件夹，选择onefile，生成一个文件。 如果项目有一些依赖的数据文件，上面生成的二进制文件是无法运行的，这个时候可以通过生成spec文件，而后再用pyinstaller运行spec文件。 pyinstaller [option] myapp.spec 最后有个坑就是目前最新版本的pyinstaller 3.2.1 不支持 python3.6。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Xcode不自动补全问题]]></title>
      <url>%2F2017%2F04%2F13%2FXcode%E4%B8%8D%E8%87%AA%E5%8A%A8%E8%A1%A5%E5%85%A8%E9%97%AE%E9%A2%98%2F</url>
      <content type="text"><![CDATA[1.要import pods里的头文件有时候XCode搜索头文件不会去搜索Pods里的第三方库，我们需要在XCode里设置一下项目Target的Search Paths。 双击User Header Search Paths的空白处，填入”$(PODS_ROOT)”(没有引号), 设置为递归的搜索recursive，问题解决了。 2.XCode自带BUG有些时候我们没有调用第三方库，发现UIkit的自动补全都没法触发了，这样的原因多半是因为XCode自带BUG，在你的注释里有中文的时候，不会触发自动补全，比如这个’年’，删掉过后再编译一下试试，再不行就重启一下XCode。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[基础算法(堆排序)]]></title>
      <url>%2F2017%2F01%2F30%2F%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95(%E5%A0%86%E6%8E%92%E5%BA%8F)%2F</url>
      <content type="text"><![CDATA[堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。 算法步骤 先将初始文件Array[1..n]建成一个大根堆，此堆为初始的无序区。 再将关键字最大的记录Array[1]（即堆顶）和无序区的最后一个记录Array[n]交换，由此得到新的无序区Array[1..n-1]和有序区Array[n]，然后再把无序区建成一个大根堆，然后再次将Array[1..n-1]中关键字最大的记录Array[1]和该区间的最后一个记录Array[n-1]交换. 下面是算法的Swift实现: /// 将Array中的index位置堆化////// - Parameters:/// - array: 数组/// - index: 位置/// - end: 数组的最后位置func maxHeapify(array: inout [Int], index:Int, end:Int)&#123; var parentIndex = index var endIndex = end while true &#123; var leftChildIndex = parentIndex * 2 + 1 var rightChildIndex = leftChildIndex + 1 var childIndex = leftChildIndex if childIndex &gt; endIndex &#123; break &#125; if childIndex + 1 &lt;= endIndex &amp;&amp; array[leftChildIndex] &lt; array[rightChildIndex] &#123; childIndex += 1 &#125; if array[parentIndex] &lt; array[childIndex]&#123; swap(&amp;array[childIndex], &amp;array[parentIndex]) parentIndex = childIndex &#125;else&#123; break &#125; &#125;&#125;/// 创建大根堆func creatMaxHeap(array: inout [Int])&#123; for i in (0...(array.count - 1) / 2).reversed()&#123; maxHeapify(array: &amp;array, index: i, end: array.count - 1) &#125;&#125;/// 堆排序func heapSort(array: inout [Int])&#123; creatMaxHeap(array: &amp;array) for i in (0...array.count - 1).reversed()&#123; if i != 0&#123; swap(&amp;array[0], &amp;array[i]) &#125; maxHeapify(array: &amp;array, index: 0, end: i - 1) &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[基础算法(快速排序)]]></title>
      <url>%2F2017%2F01%2F29%2F%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95(%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F)%2F</url>
      <content type="text"><![CDATA[Quicksort又称划分交换排序，最早由东尼·霍尔提出。在平均状况下，排序n个项目要Ο(n log n)次比较。在最坏状况下则需要Ο(n2)次比较，但这种状况并不常见。事实上，快速排序通常明显比其他Ο(n log n)算法更快，因为它的内部循环（inner loop）可以在大部分的架构上很有效率地被实现出来。 快速排序使用分治法（Divide and conquer）策略来把一个串行（list）分为两个子串行（sub-lists）。 算法步骤 从数列中挑出一个元素，称为 “基准”（pivot）， 重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作。 递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。 递归的最底部情形，是数列的大小是零或一，也就是永远都已经被排序好了。虽然一直递归下去，但是这个算法总会退出，因为在每次的迭代（iteration）中，它至少会把一个元素摆到它最后的位置去。 Swift代码由上面的步骤我们可以写出一个简单的快排算法： func quickSortSimple(array:[Int]) -&gt; [Int]&#123; if array.count &lt;= 1 &#123; return array &#125; var lowArray = [Int](), highArray = [Int]() var pivot = array.first! for i in 1...array.count - 1&#123; let num = array[i] if num &gt; pivot&#123; highArray.append(num) &#125;else&#123; lowArray.append(num) &#125; &#125; var result = quickSortSimple(array: lowArray) result.append(pivot) let highResult = quickSortSimple(array: highArray) result.append(contentsOf: highResult) return result&#125; 上面简单版本有个缺点，就是它需要Ω(n)的额外存储空间。额外需要的存储器空间配置，在实际上的实现，也会极度影响速度和缓存的性能。有一个比较复杂使用原地（in-place）分区算法的版本如下: //用于将func partition(a: inout [Int],low:Int,high:Int) -&gt; Int&#123; if low &gt;= high&#123; return low &#125; let pivot = a[low] var i = low, j = high while i &lt; j &#123; while i &lt; j &amp;&amp; a[j] &gt;= pivot &#123; j -= 1 &#125; while i &lt; j &amp;&amp; a[i] &lt;= pivot &#123; i += 1 &#125; if i &lt; j &#123; swap(&amp;a[i], &amp;a[j]) &#125; &#125; if i != low&#123; swap(&amp;a[i], &amp;a[low]) &#125; return i&#125;func quickSort(array: inout [Int], low:Int, high:Int)&#123; if low &gt; high&#123; return &#125; let index = partition(a: &amp;array, low: low, high: high) quickSort(array: &amp;array, low: low, high: index - 1) quickSort(array: &amp;array, low: index + 1, high: high)&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[iOS常用宏定义（Siwft篇）]]></title>
      <url>%2F2016%2F10%2F14%2FiOS%E5%B8%B8%E7%94%A8%E5%AE%8F%E5%AE%9A%E4%B9%89%EF%BC%88Swift%E7%AF%87%EF%BC%89%2F</url>
      <content type="text"><![CDATA[swift中并没有宏定义，只是用全局常量和利用函数获取全局常量的方式实现了OC中的宏定义功能。 屏幕let SCREEN_HEIGHT = UIScreen.mainScreen().bounds.heightlet SCREEN_WIDTH = UIScreen.mainScreen().bounds.widthlet FIT_WIDTH = UIScreen.mainScreen().bounds.size.width / 375let FIT_HEIGHT = UIScreen.mainScreen().bounds.size.height / 667 最好的办法是使用结构体： struct ScreenSize &#123; static let height = UIScreen.mainScreen().bounds.height static let width = UIScreen.mainScreen().bounds.width&#125; 系统//系统struct System &#123; static let version = UIDevice .currentDevice().systemVersion&#125; Log/// Logfunc printLog&lt;T&gt;(message: T, file: String = #file, method: String = #function, line: Int = #line)&#123; #if DEBUG print("Log:\((file as NSString).lastPathComponent)[\(line)], \(method): \(message)") #endif&#125;/// Errorfunc printError&lt;T&gt;(message: T, file: String = #file, method: String = #function, line: Int = #line)&#123; #if DEBUG print("Error:\((file as NSString).lastPathComponent)[\(line)], \(method): \(message)") #endif&#125; UIView使用Extension // MARK: - UIView 扩展extension UIView&#123; var x:CGFloat&#123; return frame.origin.x &#125; var y:CGFloat&#123; return frame.origin.y &#125; var width:CGFloat&#123; return frame.size.width &#125; var height:CGFloat&#123; return frame.size.height &#125;&#125; 设备public enum DeviceModel : String &#123; case Simulator = "Simulator/Sandbox", iPod1 = "iPod 1", iPod2 = "iPod 2", iPod3 = "iPod 3", iPod4 = "iPod 4", iPod5 = "iPod 5", iPad2 = "iPad 2", iPad3 = "iPad 3", iPad4 = "iPad 4", iPhone4 = "iPhone 4", iPhone4S = "iPhone 4S", iPhone5 = "iPhone 5", iPhone5S = "iPhone 5S", iPhone5C = "iPhone 5C", iPadMini1 = "iPad Mini 1", iPadMini2 = "iPad Mini 2", iPadMini3 = "iPad Mini 3", iPadAir1 = "iPad Air 1", iPadAir2 = "iPad Air 2", iPhone6 = "iPhone 6", iPhone6plus = "iPhone 6 Plus", iPhone6S = "iPhone 6S", iPhone6Splus = "iPhone 6S Plus", iPhone7 = "iPhone 7", iPhone7plus = "iPhone 7 Plus", Unrecognized = "unrecognized"&#125;extension UIDevice&#123; /// 获取当前设备详细类型 public var deviceModel: DeviceModel&#123; var systemInfo = utsname() uname(&amp;systemInfo) let machineMirror = Mirror(reflecting: systemInfo.machine) let identifier = machineMirror.children.reduce("") &#123; identifier, element in guard let value = element.value as? Int8 , value != 0 else &#123; return identifier &#125; return identifier + String(UnicodeScalar(UInt8(value))) &#125; var modelMap : [ String : DeviceModel ] = [ "i386" : .Simulator, "x86_64" : .Simulator, "iPod1,1" : .iPod1, "iPod2,1" : .iPod2, "iPod3,1" : .iPod3, "iPod4,1" : .iPod4, "iPod5,1" : .iPod5, "iPad2,1" : .iPad2, "iPad2,2" : .iPad2, "iPad2,3" : .iPad2, "iPad2,4" : .iPad2, "iPad2,5" : .iPadMini1, "iPad2,6" : .iPadMini1, "iPad2,7" : .iPadMini1, "iPhone3,1" : .iPhone4, "iPhone3,2" : .iPhone4, "iPhone3,3" : .iPhone4, "iPhone4,1" : .iPhone4S, "iPhone5,1" : .iPhone5, "iPhone5,2" : .iPhone5, "iPhone5,3" : .iPhone5C, "iPhone5,4" : .iPhone5C, "iPad3,1" : .iPad3, "iPad3,2" : .iPad3, "iPad3,3" : .iPad3, "iPad3,4" : .iPad4, "iPad3,5" : .iPad4, "iPad3,6" : .iPad4, "iPhone6,1" : .iPhone5S, "iPhone6,2" : .iPhone5S, "iPad4,1" : .iPadAir1, "iPad4,2" : .iPadAir2, "iPad4,4" : .iPadMini2, "iPad4,5" : .iPadMini2, "iPad4,6" : .iPadMini2, "iPad4,7" : .iPadMini3, "iPad4,8" : .iPadMini3, "iPad4,9" : .iPadMini3, "iPhone7,1" : .iPhone6plus, "iPhone7,2" : .iPhone6, "iPhone8,1" : .iPhone6S, "iPhone8,2" : .iPhone6Splus, "iPhone9,1" : .iPhone7, "iPhone9,2" : .iPhone7plus ] if let model = modelMap[identifier] &#123; return model &#125; return DeviceModel.Unrecognized &#125; /// 判断是不是iPhone var isiPhone:Bool&#123; return model == "iPhone" &#125; /// 判断是不是iPad var isiPad:Bool&#123; return model == "iPad" &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[R.swift使用]]></title>
      <url>%2F2016%2F09%2F14%2FR.swift%E4%BD%BF%E7%94%A8%2F</url>
      <content type="text"><![CDATA[安装使用CocoaPods来对R.Swift进行安装： pod &#39;R.swift&#39; 配置 进入项目的配置界面，在左边的TARGETS项下面选择我们的项目，并在右边点击Build Phases这个tab。 进入&lt;Build Phases&gt;这个tab后，我们看到左上角有一个”+”按钮，点击并在弹出的选项卡中选择New Run Script Phase。 我们会看到界面的下方多出了一个Run Script项，展开它，并在脚本输入区域输入&quot;\$PODS_ROOT/R.swift/rswift&quot; “\$SRCROOT” (第二对双引号括起来所代码的是项目的根目录，你也可以放到根目录下的其他目录中，只需将其修改为”$SRCROOT/XXX”，XXX为目标目录名)。4.我们按住新建的这个Run Script项向上移动，移到Compile Source项的上方，不过也要保证此时它也在Check Pods Manifest.lock项的下方。 Command + B，编译一下，编译成功后，在Finder进入到刚刚我们制定的目录中，此时我们会看到一个名为R.generated.swift的文件已经创建了，直接把此文件拖入Xcode项目中，记住不要勾选Copy items if needed项。 配置到此完成，我们可以构建自己的项目了 使用Image - 图片// 不使用R.Swiftlet pImage = UIImage(named: "image_test")// 使用R.Swiftlet nImage = R.image.image_test() File - 数据文件// 不使用R.Swiftlet pFile = NSBundle.mainBundle().pathForResource("DataFile", ofType: "json")// 使用R.Swiftlet nFile = R.file.dataFileJson.path() Font - 字体// 不使用R.Swiftlet pFont = UIFont(name: "chalkduster", size: 35)// 使用R.Swiftlet nFont = R.font.chalkduster(size: 35)// 你看，非常神奇，在上面的方法中你不仅可以选择字体类型，还能设置字体大小 Color - 颜色把.clr文件拖入项目中即可使用颜色配置let appRedColor = R.color.myAppColor.red() Nibs不使用R.swift let nameOfNib = "CustomView"let customViewNib = UINib(nibName: "CustomView", bundle: nil)let rootViews = customViewNib.instantiate(withOwner: nil, options: nil)let customView = rootViews[0] as? CustomViewlet viewControllerWithNib = CustomViewController(nibName: "CustomView", bundle: nil) 使用 R.swift let nameOfNib = R.nib.customView.namelet customViewNib = R.nib.customView()let rootViews = R.nib.customView.instantiateWithOwner(nil)let customView = R.nib.customView.firstView(owner: nil)let viewControllerWithNib = CustomViewController(nib: R.nib.customView) Localized strings不使用R.swift let welcomeMessage = NSLocalizedString("welcome.message", comment: "")let settingsTitle = NSLocalizedString("title", tableName: "Settings", comment: "")// Formatted stringslet welcomeName = String(format: NSLocalizedString("welcome.withName", comment: ""), locale: NSLocale.current, "Alice")// Stringsdict fileslet progress = String(format: NSLocalizedString("copy.progress", comment: ""), locale: NSLocale.current, 4, 23) 使用 R.swift // Localized strings are grouped per table (.strings file)let welcomeMessage = R.string.localizable.welcomeMessage()let settingsTitle = R.string.settings.title()// Functions with parameters are generated for format stringslet welcomeName = R.string.localizable.welcomeWithName("Alice")// Functions with named argument labels are generated for stringsdict keyslet progress = R.string.localizable.copyProgress(completed: 4, total: 23)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[iOS常用的第三方库]]></title>
      <url>%2F2016%2F09%2F14%2FiOS%E5%B8%B8%E7%94%A8%E7%9A%84%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93%2F</url>
      <content type="text"><![CDATA[DZNEmptyDataSet （空白提示-提升用户体验） github地址 MagicalRecord （数据库-CoreData的封装） github地址 Chameleon (色彩框架） github地址 TextFieldEffects （文本输入框） github地址 Spring （动画框架） github地址 GPUImage (图片处理) github地址 iRate (用户评论) github地址 MGSwipeTableCell (可滑动cell) github地址 FontBlaster （自定义字体加载到APP） github地址 quick (单元测试) github地址 FlatUIKit (扁平化UI的iOS组件) github地址 AlamofireObjectMapper (JSON数据转换成对象) github地址 SnipKit (Masonry Swift版本 自动布局) github地址 Shimmer (有闪烁效果的第三方控件) github地址 RESideMenu (侧滑效果) github地址 RealtimeGradientText (渐变label) github地址 JVFloatLabeledTextField (floating textfield) github地址 SWTableViewCell (滑动Cell) github地址 MonkeyKing （社交分享） github地址 R.swift （以一种优雅安全的方式使用资源文件） github地址 Moya (Alamofire的封装) github地址 SwiftyUserDefaults (UserDefults 封装) github地址 SwiftyUserDefaults 使用 FillableLoaders (自定义的进度加载动画) github地址 SwiftString （字符串扩展） github地址 ExSwift (Swift基础类型扩展库) github地址 Koloda （卡片视图） github地址 ImagePicker （图片选择器） github地址 Material github地址 IFTTT/RazzleDazzle (集成引导页，IFTTT) github地址 Instructions (用法指南，介绍页面) github地址 Animated Tab Bar （动画Tab Bar） github地址 Adaptive Tab Bar github地址 ESTabBarController （Tab Bar） github地址 Eureka (动态TableView) github地址 用法 folding-cell (折叠动画cell) github地址 SCLAlertView (alert view) github地址 SweetAlert-iOS (alert view) github地址 DOFavoriteButton (twitter 风格点赞按钮) github地址 LiquidFloatingActionButton (floating button 动画nice) github地址 ZFRippleButton （Material 风格按钮） github地址 DynamicButton (动态按钮) github地址 paper-switch (改变父视图效果的Switch) github地址 LTMorphingLabel （动画Label） github地址 ActiveLabel.swift （有很多效果的label hashtag） github地址 TextFieldEffects （有很多效果的textfield） github地址 PhoneNumberKit (针对电话输入的textfield) github地址 SkyFloatingLabelTextField （Material 风格textfield） github地址 NextGrowingTextView (自适应高度的TextView) github地址 Hue (颜色 color) github地址 TextAttributes (封装 NSAttributeString) github地址 SwiftOCR github地址 Gifu (GIF) github地址 FlowingMenu (手势侧滑menu) github地址 circle-menu （圆形动画菜单） github地址 PageMenu （分页效果） github地址 XLPagerTabStrip (Material 风格分页效果) github地址 Timepiece （NSDate相关） github地址 Cosmos (评分控件) github地址]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[iOS常用宏定义（OC篇）]]></title>
      <url>%2F2016%2F07%2F14%2FiOS%E5%B8%B8%E7%94%A8%E5%AE%8F%E5%AE%9A%E4%B9%89%EF%BC%88OC%E7%AF%87%EF%BC%89%2F</url>
      <content type="text"><![CDATA[OC//获取屏幕宽度和高度#define SCREEN_WIDTH [UIScreen mainScreen].bounds.size.width#define SCREENH_HEIGHT [UIScreen mainScreen].bounds.size.height //支持横屏的宽度和高度#if __IPHONE_OS_VERSION_MAX_ALLOWED &gt;= 80000 // 当前Xcode支持iOS8及以上#define SCREEN_WIDTH ([[UIScreen mainScreen] respondsToSelector:@selector(nativeBounds)]?[UIScreen mainScreen].nativeBounds.size.width/[UIScreen mainScreen].nativeScale:[UIScreen mainScreen].bounds.size.width)#define SCREENH_HEIGHT ([[UIScreen mainScreen] respondsToSelector:@selector(nativeBounds)]?[UIScreen mainScreen].nativeBounds.size.height/[UIScreen mainScreen].nativeScale:[UIScreen mainScreen].bounds.size.height)#define SCREEN_SIZE ([[UIScreen mainScreen] respondsToSelector:@selector(nativeBounds)]?CGSizeMake([UIScreen mainScreen].nativeBounds.size.width/[UIScreen mainScreen].nativeScale,[UIScreen mainScreen].nativeBounds.size.height/[UIScreen mainScreen].nativeScale):[UIScreen mainScreen].bounds.size)#else#define SCREEN_WIDTH [UIScreen mainScreen].bounds.size.width#define SCREENH_HEIGHT [UIScreen mainScreen].bounds.size.height#define SCREEN_SIZE [UIScreen mainScreen].bounds.size#endif//通知中心#define LRNotificationCenter [NSNotificationCenter defaultCenter]//获取随机颜色#define LRRandomColor [UIColor colorWithRed:arc4random_uniform(256)/255.0 green:arc4random_uniform(256)/255.0 blue:arc4random_uniform(256)/255.0 alpha:1.0]//设置RGB颜色#define LRRGBColor(r, g, b) [UIColor colorWithRed:(r)/255.0 green:(g)/255.0 blue:(b)/255.0 alpha:1.0]#define LRRGBAColor(r, g, b, a) [UIColor colorWithRed:(r)/255.0 green:(r)/255.0 blue:(r)/255.0 alpha:a]// clear背景颜色#define LRClearColor [UIColor clearColor]//Log#ifdef DEBUG#define XYLog(...) NSLog(@"%s 第%d行 \n %@\n\n",__func__,__LINE__,[NSString stringWithFormat:__VA_ARGS__])#else#define XYLog(...)#endif//判断是否为iPhone#define IS_IPHONE (UI_USER_INTERFACE_IDIOM() == UIUserInterfaceIdiomPhone)#define IS_IPHONE ([[[UIDevice currentDevice] model] isEqualToString:@"iPhone"])//判断是否为iPad#define IS_IPAD (UI_USER_INTERFACE_IDIOM() == UIUserInterfaceIdiomPad)#define IS_IPAD ([[[UIDevice currentDevice] model] isEqualToString:@"iPad"])//判断是否为ipod#define IS_IPOD ([[[UIDevice currentDevice] model] isEqualToString:@"iPod touch"])// 判断是否为 iPhone 5SE#define iPhone5SE [[UIScreen mainScreen] bounds].size.width == 320.0f &amp;&amp; [[UIScreen mainScreen] bounds].size.height == 568.0f// 判断是否为iPhone 6/6s#define iPhone6_6s [[UIScreen mainScreen] bounds].size.width == 375.0f &amp;&amp; [[UIScreen mainScreen] bounds].size.height == 667.0f// 判断是否为iPhone 6Plus/6sPlus#define iPhone6Plus_6sPlus [[UIScreen mainScreen] bounds].size.width == 414.0f &amp;&amp; [[UIScreen mainScreen] bounds].size.height == 736.0f//获取系统版本#define IOS_SYSTEM_STRING [[UIDevice currentDevice] systemVersion]//判断 iOS 8 或更高的系统版本#define IOS_VERSION_8_OR_LATER (([[[UIDevice currentDevice] systemVersion] floatValue] &gt;=8.0)? (YES):(NO))// 判断是不是iOS系统，如果是iOS系统在真机和模拟器输出都是YES#if TARGET_OS_IPHONE #endif #if (TARGET_IPHONE_SIMULATOR) // 在模拟器的情况下#else // 在真机情况下#endif//获取temp#define kPathTemp NSTemporaryDirectory()//获取沙盒 Document#define kPathDocument [NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES) firstObject]//获取沙盒 Cache#define kPathCache [NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES) firstObject]]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Swift 中泛型的使用]]></title>
      <url>%2F2015%2F10%2F15%2FSwift-%E4%B8%AD%E6%B3%9B%E5%9E%8B%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
      <content type="text"><![CDATA[对于类型安全(type-safe)语言，一个常见的问题就是如何编写适用于多种类型输入的程序。想象一下，两个整型数相加和两个浮点数相加的程序看起来应该非常类似，甚至一模一样才对。唯一的区别就是变量的类型不同。 在强类型语言中，你需要去定义诸如addInts, addFloats, addDoubles 等方法来正确地处理参数及返回值。 许多编程语言已经解决了这个问题。例如，在C++中，使用Template来解决。而Swift，Java和C#则采用了泛型来解决这个问题。 下面用有序字典（Ordered Dictionaries）来简单说明一下泛型的用法： 和数组不同的是，包括Swift在内地很多编程语言和框架都不保证集合(sets)和字典(dictionaries)的数据存储顺序。有序字典和普通的字典类似，不同之处在于它的key是有序的。 创建有序字典点击“文件\新建\文件…”新建一个文件，并选择“IOS\Source\Swift File”。点击“下一步”并把这个文件命名为“OrderedDictionary”。最后，点击“创建”。 你会得到一个空的Swift文件，加这样一段代码进去： struct OrderedDictionary &#123; &#125; 到现在为止应该都没有什么问题。通过语义可以看出这个对象是一个结构体。 现在你需要将其一般化，以便它能够装载你需要的任何类型的数据。通过下列改变你对Swift中“结构”的定义： struct OrderedDictionary&lt;KeyType, ValueType&gt; 在尖括弧中的元素是通用类型的参数。KeyType和ValueType不是他们自身的类型，而是你可以使用在结构里定义取代的类型。现在就简洁清新许多了！ 最简单的实现一个有顺序的字典是保持一个数组和一个字典。字典中将会装载衍射，而数组将装载keys的顺序。 在结构体内部的定义中，加入以下的代码： typealias ArrayType = [KeyType]typealias DictionaryType = [KeyType: ValueType]var array = ArrayType()var dictionary = DictionaryType() 这样声明有两个目的，就像上例描述的，有两种类型的用于给已经存在的类型的取新的名称的别名。在这，你将分别地为后面的数组和字典赋值了别名。声明别名是将复杂类型定义为更短名称的类型的一种非常有效的方式。 你将注意怎么样从结构体中定义用“KeyType”和“ValueType”的参数类型中替换类型。上例的”KeyTypes”是数组类型的。当然这是没有这样的类型的“KeyType”；当在一般的实例化时，将替代Swift像对OrderedDictionary的类型的一切类型通过。 就因为这样，你将会注意到编译错误： Type &apos;Keytype&apos; does not conform to protocol &apos;Hashable&apos; 这是因为你的字典Key没有遵循Hashable协议； 我们可以手动修改代码让Key遵循Hashable协议： struct OrderedDictionary&lt;KeyType: Hashable, ValueType 接下来我们就需要正式建立有序字典了； 添加count属性 var count: Int &#123; return self.array.count&#125; 添加插入和移除方法 mutating func removeAtIndex(index: Int) -&gt; (KeyType, ValueType) &#123; precondition(index &lt; self.array.count, "Index 超出范围") assert(index &lt; self.array.count) let key = self.array.removeAtIndex(index) let value = self.dictionary.removeValueForKey(key)! return (key, value)&#125;mutating func insert(value: ValueType, forKey key: KeyType, atIndex index:Int) -&gt; ValueType? &#123; var adjustedIndex = index let existingValue = self.dictionary[key] if existingValue != nil &#123; let existingIndex = self.array.indexOf(key) if existingIndex &lt; index &#123; adjustedIndex-- &#125; self.array.removeAtIndex(existingIndex!) &#125; self.array.insert(key, atIndex: adjustedIndex) self.dictionary[key] = value return existingValue&#125; 注意在结构体内如果方法需要修改结构体内的属性的话，要在方法前加mutating关键字； 添加下标访问方法： subscript(key: KeyType) -&gt; ValueType? &#123; get &#123; return self.dictionary[key] &#125; set &#123; if let _ = self.array.indexOf(key) &#123;&#125;else &#123; self.array.append(key) &#125; self.dictionary[key] = newValue &#125;&#125;subscript(index: Int) -&gt;(KeyType, ValueType) &#123; get &#123; precondition(index &lt; self.array.count, "Index 超出范围") let key = self.array[index] let value = self.dictionary[key]! return (key, value) &#125;&#125; 这样我们就利用泛型创建了一个有序字典。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Swift单例]]></title>
      <url>%2F2015%2F10%2F15%2FSwift%E5%8D%95%E4%BE%8B%2F</url>
      <content type="text"><![CDATA[单例是一个在 Cocoa 中很常用的模式了。对于一些希望能在全局方便访问的实例，或者在 app 的生命周期中只应该存在一个的对象，我们一般使用单例来存储和访问。在 Objective-C 中单例的公认的写法类似下面这样： @implementation MyManager+ (id)sharedManager &#123; static MyManager *staticInstance = nil; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; staticInstance = [[self alloc] init]; &#125;); return staticInstance;&#125;@end 使用 GCD 中的 dispatch_once_t 可以保证里面的代码只被调用一次，以此保证单例在线程上的安全。 因为在 Swift 中可以无缝直接使用 GCD，所以我们可以很方便地把类似方式的单例用 Swift 进行改写： class MyManager &#123; class var sharedManager : MyManager &#123; struct Static &#123; static var onceToken : dispatch_once_t = 0 static var staticInstance : MyManager? = nil &#125; dispatch_once(&amp;Static.onceToken) &#123; Static.staticInstance = MyManager() &#125; return Static.staticInstance! &#125;&#125; 因为 Swift 现在还暂时不支持存储的 class var，所以我们需要使用一个 struct 来存储类型变量。 这样的写法当然没什么问题，但是在 Swift 里我们其实有一个更简单的保证线程安全的方式，那就是 let。把上面的写法简化一下，可以变成： class MyManager &#123; class var sharedManager : MyManager &#123; struct Static &#123; static let sharedInstance : MyManager = MyManager() &#125; return Static.sharedInstance &#125;&#125; 还有另一种更受大家欢迎，并被认为是当前的最佳实践的做法。由于现在 class 不支持存储式的 property，我们想要使用一个只存在一份的属性时，就只能将其定义在全局的 scope 中。值得庆幸的是，在 Swift 拥有访问级别控制后，我们可以在变量定义前面加上 private 关键字，使这个变量只在当前文件中可以被访问。这样我们就可以写出一个没有嵌套的，语法上也更简单好看的单例了： private let sharedInstance = MyManager()class MyManager &#123; class var sharedManager : MyManager &#123; return sharedInstance &#125;&#125; 最后一种是最简单也是最实用的，是swift给的语法糖]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[设计模式]]></title>
      <url>%2F2015%2F09%2F29%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F</url>
      <content type="text"><![CDATA[设计模式是为了解决特定问题而出现的； 设计模式的基本原则： 开闭原则模块应该对扩展开放而对修改关闭； 里氏代换原则父类和子类之间的方法可以相互调换，从而方便修改；多态 依赖倒转原则抽象不依赖于细节，细节依赖于抽象； 接口隔离原则尽量保证接口只做必要的事情； 合成/聚合复用 适配器模式比如iOS从网络请求加载数据，更新UI的时候，我们会初始化出一个model，随着后续版本的升级，这个model会持续添加参数，或者减少参数；此时如果我们直接修改这个model的话，那么就要同时修改与这个model相匹配的view，这样就会一只在两者之间修改来修改去，适配器模式就是为了解决这种问题存在的。 如果你运用了适配器模式，那么我们的model不会直接与view接触，它会先和适配器接触，然后再通过适配器去更新UI TODO]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[CocoaPods Podfile]]></title>
      <url>%2F2015%2F09%2F29%2FCocoaPods%20Podfile%2F</url>
      <content type="text"><![CDATA[什么是PodfilePodfile是一个规范，描述了一个或多个一套工程目标的依赖项 一个简单写法: target 'MyApp' do pod 'AFNetworking', '~&gt; 3.0'end 更复杂的一个例子： # 下面两行是指明依赖库的来源地址source 'https://github.com/CocoaPods/Specs.git'source 'https://github.com/Artsy/Specs.git'# 说明平台是ios，版本是9.0platform :ios, '9.0'# 忽略引入库的所有警告（强迫症者的福音啊）inhibit_all_warnings!# 针对MyApp target引入AFNetworking# 针对MyAppTests target引入OCMock，target 'MyApp' do pod 'AFNetworking', '~&gt; 3.0' target 'MyAppTests' do inherit! :search_paths pod 'OCMock', '~&gt; 2.0.1' endend# 这个是cocoapods的一些配置,官网并没有太详细的说明,一般采取默认就好了,也就是不写.post_install do |installer| installer.pods_project.targets.each do |target| puts target.name endend From a podspec in the root of a library repository (引用仓库根目录的podspec)有时我们需要引入依赖库指定的分支或节点，写法如下。 引入master分支（默认） pod &#39;AFNetworking&#39;, :git =&gt; &#39;https://github.com/gowalla/AFNetworking.git&#39; 引入指定的分支 pod &#39;AFNetworking&#39;, :git =&gt; &#39;https://github.com/gowalla/AFNetworking.git&#39;, :branch =&gt; &#39;dev&#39; 引入某个节点的代码 pod &#39;AFNetworking&#39;, :git =&gt; &#39;https://github.com/gowalla/AFNetworking.git&#39;, :tag =&gt; &#39;0.7.0&#39; 引入某个特殊的提交节点 pod &#39;AFNetworking&#39;, :git =&gt; &#39;https://github.com/gowalla/AFNetworking.git&#39;, :commit =&gt; &#39;082f8319af&#39; 需要特别注意的是，虽然这样将会满足任何在Pod中的依赖项通过其他Pods 但是podspec必须存在于仓库的根目录中。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Mac自带Vim7.3不能使用系统剪切板解决方案]]></title>
      <url>%2F2015%2F09%2F26%2FMac%E8%87%AA%E5%B8%A6Vim7-3%E4%B8%8D%E8%83%BD%E4%BD%BF%E7%94%A8%E7%B3%BB%E7%BB%9F%E5%89%AA%E5%88%87%E6%9D%BF%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%2F</url>
      <content type="text"><![CDATA[用了Mac自带的Vim之后发现yy复制的内容和剪切板不同步，谷歌之，找到2种方法： “+y 在 ~/.vimrc 里增加 set clipboard=unnamed 但是完全不起任何作用，经过一番折腾之后才知道是Mac自带的Vim7.3版本不支持使用系统剪切板；于是就安装了MacVim，结果试了之后还是不管用，执行 vim --version | grep clip 结果还是： -clientserver -clipboard +cmdline_compl +cmdline_hist +cmdline_info +comments -xterm_clipboard -xterm_save 原因是就算你安装了MacVim使用了Vim7.4系统自带的Terminal还是会默认使用自带的7.3版本； 所以只要在profile中添加如下语句就可以解决问题了； alias vim="/Applications/MacVim.app/Contents/MacOS/Vim" 之后你在终端使用vim也会调用MacVim中的7.4版本了。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Dynamics动画]]></title>
      <url>%2F2015%2F09%2F26%2FDynamics%E5%8A%A8%E7%94%BB%2F</url>
      <content type="text"><![CDATA[UIKit Dynamics是iOS7中新推出的，可以模拟现实的二维动画效果，开发出逼真的物理动画。 关键类 UIDynamicAnimator：封装了底层的物理引擎，为动力项（UIDynamicItem）提供物理相关的功能和动画； UIDynamicBehavior，动力行为，为动力项提供不同的物理行为； UIDynamicItem，动力项，相当于现实世界中的一个基本物体； 使用方法 创建一个UIDynamicAnimator @property(strong, nonatomic) UIDynamicAnimator *dynamicAnimate;- (UIDynamicAnimator *)dynamicAnimate&#123; if (!_dynamicAnimate) &#123; _dynamicAnimate = [[UIDynamicAnimator alloc] initWithReferenceView:self.gameView]; _dynamicAnimate.delegate = self; &#125; return _dynamicAnimate;&#125; 然后就可以把动力行为加到动画中了 [self.dynamicAnimate addBehavior:_dropItemBehavior];]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[使用融云和LeanCloud 创建一个IM应用]]></title>
      <url>%2F2015%2F09%2F21%2F%E4%BD%BF%E7%94%A8%E8%9E%8D%E4%BA%91%E5%92%8CLeanCloud-%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AAIM%E5%BA%94%E7%94%A8%2F</url>
      <content type="text"><![CDATA[融云 是国内一家专门为APP开发者提供IM服务的公司，利用它提供的SDK可以快速使你的APP集成IM通讯能力。详细的使用方法在它官网的开发文档中有提供，但是不得不吐槽的就是它的开发文档写的实在太乱了让人有种无从下手的感觉，下面简单记录一下使用过程。 导入SDK推荐使用CocoaPods导入： 在Podfile中添加： pod &#39;RongCloudIMKit&#39; 然后执行命令： pod install 获取TokenToken 也叫用户令牌，是 SDK 端用来连接融云服务器的凭证，每个用户连接服务器都需要一个 Token。每次初始化连接服务器时，都需要向服务器提交 Token。获取Token需要注册一个融云的账号，然后新建一个应用，之后在API调试中填写userid（用户唯一标示符）、name（用户昵称）、portraitUri（头像url）就可以获得一个测试用的Token。 初始化和测试连接获得测试用的Token之后就可以利用AppKey（创建应用时融云给你的应用标示符）和Token对应用进行初始化了： //用AppKey初始化 RCIM.sharedRCIM().initWithAppKey("82hegw5uh4r8x") //用Token测试连接RCIM.sharedRCIM().connectWithToken(token, success: &#123; (str:String!) -&gt; Void inprint("连接成功！") //连接成功后设置当前登陆用户信息RCIMClient.sharedRCIMClient().currentUserInfo = RCUserInfo(userId: id, name: name, portrait: avatorURL)//在UserDefaults中保存TokenNSUserDefaults.standardUserDefaults().setObject(token, forKey: "kDeviceToken") //在主线程中调用更新UIdispatch_async(dispatch_get_main_queue(), &#123; () -&gt; Void in&#125;)&#125;,error: &#123; (_) -&gt; Void in print("连接错误！")&#125;)&#123; () -&gt; Void in print("Token不正确！")&#125; 连接成功后启动单聊会话融云在它的SDK中已经集成聊天用户界面，所以我们只要创建一个RCConversationViewController的实例就能使用它提供的用户界面了，同时用户界面也支持自定义，这部分在官网的开发文档中有详细的介绍，这里就不做赘述。需要注意的是：要使用RCConversationViewController，必须给它的几个属性赋值： conversationType：聊天类型，有单聊、群聊等等 self.conversationType = RCConversationType.ConversationType_PRIVATE //这里的PRIVATE是单聊 targetId：聊天目标用户id self.targerId = &quot;&quot; userName:聊天目标用户的昵称 self.userName = &quot;&quot; title:聊天界面显示的标题 self.title = self.userNameRCConversationViewController中还有其他很多的属性可以自定义，比如用户头像形状之类的，这些可以在它的头文件中找到。 测试单聊设置好以上内容之后，单聊的工作就已经做好了，现在我们可以测试单聊的效果，这里由于还没有其他的用户，我们就先和自己聊天来测试一下单聊的效果；把targerId设置成已经登录的id，然后就可以自己和自己聊天了，内部集成的界面还是挺简洁易用的，虽然是自己和自己聊天，但是他也不是在本地操作的，也要经过融云的服务器，所以你把网络断开的情况下是不能发出信息的。到这里单聊已经实现了，但是你会发现聊天界面他是不会显示用户头像的，虽然你在初始化的时候给了一个头像的url，但是他是不会加载出来的，不得不说这一点确实很脑残，主要原因是融云为了安全起见，他的服务器是不会储存用户信息的，在融云那边只有一个Token和userid的对应关系，和你发送给他的好友关系，也就是说你的用户信息需要自己在用一个服务器存起来，然后向融云提供一个用户信息提供者； 设置用户信息提供者要设置用户信息提供者首先要实现RCIMUserInfoDataSource协议，所以我们要在APP启动的时候让Appdelegate实现协议，然后： func getUserInfoWithUserId(userId: String!, completion: ((RCUserInfo!) -&gt; Void)!) &#123; let userInfo = RCUserInfo() userInfo.userId = userId switch userId&#123; case "xxx": userInfo.name = "xxx" userInfo.portraitUri = "http://7xl9qm.com1.z0.glb.clouddn.com/avatar.png" case "x": userInfo.name = "A" userInfo.portraitUri = "http://www4.qqjay.com/u/files/2011/1216/d3302821f418fc5539398cb3ba72cd8c.jpg" case "xxxxx": userInfo.name = "B" userInfo.portraitUri = "http://image.photophoto.cn/nm-6/018/030/0180300244.jpg" case "xxxx": userInfo.name = "C" userInfo.portraitUri = "http://cdn.duitang.com/uploads/item/201407/26/20140726221707_i4ZnL.thumb.224_0.jpeg" default: print("no user") &#125; completion(userInfo)&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[使用AVPlayer 播放在线音频,并实现后台锁屏播放，自动连播]]></title>
      <url>%2F2015%2F09%2F21%2F%E4%BD%BF%E7%94%A8AVPlayer-%E6%92%AD%E6%94%BE%E5%9C%A8%E7%BA%BF%E9%9F%B3%E9%A2%91%2F</url>
      <content type="text"><![CDATA[在iOS开发中，AVAudioPlayer不是不能播放在线音频的，要播放在线音频只能用以下几个方法： AVPlayer MPMoviePlayerController 能实现音乐流播（但是此方法苹果在iOS9中已经不推荐使用了） Audioqueue，Audiostream （太复杂） 第三方库AudioStreamer（只能播放在线音频） 所以用AVPlayer来实现在线音频播放是最好的选择；一下就是利用AVPlayer实现音乐流播并实现后台锁屏播放和设置自动连播的大概步骤： 项目源代码：Swift 2.0 版豆瓣电台 初始化先声明AVplayer和AVPlayerItem的实例： var musicPlayer:AVPlayer!var playerItem:AVPlayerItem? 然后在需要的播放音频的地方给它赋值： self.musicPlayer = AVPlayer()let playerLayer = AVPlayerLayer(player: self.musicPlayer)self.view.layer.addSublayer(playerLayer)let url = NSURL(string: " ")//替换当前的playerItemself.musicPlayer.replaceCurrentItemWithPlayerItem(playerItem)//开始播放self.musicPlayer.play() 以上就是实现播放在线音频的代码，但是如果要实现后台播放和自动连播的话，还要做以下工作： 自动连播//当播放完成了之后发送通知，继续播放NSNotificationCenter.defaultCenter().addObserver(self, selector: "playerItemDidReachEnd:", name: AVPlayerItemDidPlayToEndTimeNotification, object: playerItem)//没有播放完成的通知 NSNotificationCenter.defaultCenter().addObserver(self, selector: "playerItemDidNotReachEnd", name: AVPlayerItemFailedToPlayToEndTimeNotification, object: playerItem)//接受到通知后响应的方法func playerItemDidReachEnd(aNotification:NSNotification)&#123; //自动播放相关&#125;func playerItemDidNotReachEnd(aNotification:NSNotification)&#123; //歌曲没有正常播放到结束&#125; 后台播放 如果是播放本地音频的话，后台播放只要在APP启动时加上： let session = AVAudioSession.sharedInstance()try! session.setCategory(AVAudioSessionCategoryPlayback)try! session.setActive(true) 然后在info.plist文件中添加： &lt;key&gt;UIBackgroundModes&lt;/key&gt;&lt;array&gt;&lt;string&gt;audio&lt;/string&gt;&lt;/array&gt; 即可。 但是如果每一首歌都要请求网络的话，只做上述工作时行不通的，还要在实例化AVPlayer的地方加上： //后台播放var bgTask:UIBackgroundTaskIdentifier = 0if UIApplication.sharedApplication().applicationState == UIApplicationState.Background &#123; self.musicPlayer.play() netMusicIsPlaying = true let app:UIApplication = UIApplication.sharedApplication() let newTask:UIBackgroundTaskIdentifier = app.beginBackgroundTaskWithExpirationHandler(nil)if newTask != UIBackgroundTaskInvalid &#123; app.endBackgroundTask(bgTask) &#125; bgTask = newTask&#125;else&#123; self.musicPlayer.play() netMusicIsPlaying = true isPlayOffline = false&#125; 这样才能实现真正的后台播放。 锁屏界面和控制中心添加详情首先要作以下准备工作 在applicationDidEnterBackground中添加：application.beginReceivingRemoteControlEvents() 在ViewDidAppear中添加： UIApplication.sharedApplication().beginReceivingRemoteControlEvents()self.becomeFirstResponder() 在viewDidDisappear中添加： UIApplication.sharedApplication().endReceivingRemoteControlEvents()self.resignFirstResponder() 重写canBecomeFirstResponder方法 override func canBecomeFirstResponder() -&gt; Bool &#123; return true&#125; 然后把歌曲详情设置到锁屏界面： func configNowPlayingInfoCenter()&#123; if (NSClassFromString("MPNowPlayingInfoCenter") != nil) &#123; //锁屏界面图片的存储方式 let mArt:MPMediaItemArtwork = MPMediaItemArtwork(image: currentSongPic) //锁屏界面信息字典 var dic:[String : AnyObject] = [ MPMediaItemPropertyTitle : currentSongTitle, MPMediaItemPropertyArtist : currentSongArtist, MPMediaItemPropertyArtwork : mArt ] //获取当前播放的时间和歌曲总时长 let time = self.musicPlayer.currentTime() let duration = self.musicPlayer.currentItem!.asset.duration //把信息传递给锁屏界面 dic.updateValue(NSNumber(double: CMTimeGetSeconds(time)), forKey: MPNowPlayingInfoPropertyElapsedPlaybackTime ) dic.updateValue(NSNumber(double: CMTimeGetSeconds(duration)), forKey: MPMediaItemPropertyPlaybackDuration) dic.updateValue(NSNumber(float: 1.0), forKey: MPNowPlayingInfoPropertyPlaybackRate) MPNowPlayingInfoCenter.defaultCenter().nowPlayingInfo = dic &#125;&#125; 再处理锁屏和控制中心点击事件： override func remoteControlReceivedWithEvent(event: UIEvent?) &#123; if event!.type == UIEventType.RemoteControl &#123; if event!.subtype == UIEventSubtype.RemoteControlNextTrack &#123; //下一曲 &#125;else if event!.subtype == UIEventSubtype.RemoteControlPause&#123; //暂停按钮 &#125;else if event!.subtype == UIEventSubtype.RemoteControlPlay&#123; //播放按钮 &#125; &#125;&#125; 利用KVO监视播放器的缓存状态和播放状态//先移除观察者 if self.musicPlayer.currentItem != nil &#123; self.musicPlayer.currentItem?.removeObserver(self, forKeyPath: "status") self.musicPlayer.currentItem?.removeObserver(self, forKeyPath: "loadedTimeRanges")&#125;//添加观察者playerItem.addObserver(self, forKeyPath: "status", options: .New, context: nil)playerItem.addObserver(self, forKeyPath: "loadedTimeRanges", options: .New, context: nil)//播放状态playerItem.addObserver(self, forKeyPath: "status", options: .New, context: nil)//缓存进度playerItem.addObserver(self, forKeyPath: "loadedTimeRanges", options: .New, context: nil)//属性改变了要实现的方法override func observeValueForKeyPath(keyPath: String?, ofObject object: AnyObject?, change: [String : AnyObject]?, context: UnsafeMutablePointer&lt;Void&gt;) &#123; //获取缓存进度 if keyPath == "loadedTimeRanges" &#123; let array = (object as! AVPlayerItem).loadedTimeRanges if let range = array.first &#123; //当前缓存的总时间 let rangeValue = range.CMTimeRangeValue let duration = rangeValue.duration //总时间换算成秒数 let loadTime = CMTimeGetSeconds(duration) &#125;else&#123; //获取当前播放状态 &#125;&#125; 获取到了缓存时间可以判断当前的缓存时间和当前播放时间的值，来判断网络状况，同时也可以在做视频播放器时用来作缓存条。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[iOS 常用第三方库7(Reachability)]]></title>
      <url>%2F2015%2F09%2F21%2FReachability%20%E4%BD%BF%E7%94%A8%2F</url>
      <content type="text"><![CDATA[Reachability 是一个检测网络状态的框架。开发Web等网络应用程序的时候，需要确认网络环境，连接情况等信息。如果没有处理这些信息的话，是不会通过Apple的审查的。 使用方法：将Reachability.h 和 Reachability.m 拷贝到你的工程中。 然后： var reach:Reachability?func checkNetStatus()&#123; self.reach = Reachability.reachabilityForInternetConnection() // Tell the reachability that we DON'T want to be reachable on 3G/EDGE/CDMA self.reach!.reachableOnWWAN = false if reach?.currentReachabilityStatus() == NetworkStatus.ReachableViaWWAN &#123; self.net = NetState.Mobile &#125; // Here we set up a NSNotification observer. The Reachability that caused the notification // is passed in the object parameter NSNotificationCenter.defaultCenter().addObserver(self, selector: "reachabilityChanged:", name: kReachabilityChangedNotification, object: nil) self.reach!.startNotifier() &#125; func reachabilityChanged(notification: NSNotification)&#123; if self.reach!.isReachableViaWiFi() &#123; print("能访问网络") &#125;else if self.reach!.isReachableViaWWAN()&#123; appDelegate.isCanUseNetWork = true print("正在使用移动网络") &#125;else &#123; print("没有网络!!!") self.net = NetState.None &#125; &#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[SDWebImage使用]]></title>
      <url>%2F2015%2F09%2F20%2FSDWebImage%E4%BD%BF%E7%94%A8%2F</url>
      <content type="text"><![CDATA[SDWebImage是一个著名的第三方库，它的作用是： Asynchronous image downloader with cache support with an UIImageView category.就是一个异步加载图片并且支持缓存的UIImage分类； 使用方法：imageView.sd_setImageWithURL(NSURL(string: ""), placeholderImage: UIImage(named: "placeholder")) 清除缓存： SDImageCache.sharedImageCache().cleanDisk()SDImageCache.sharedImageCache().clearMemory() 这个框架使用简单，然而而其中复杂的实现细节全部隐藏在这行代码之后；这边有一篇它的源代码分析：http://draveness.me/ios-yuan-dai-ma-jie-xi-sdwebimage/]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Facebook 动画库POP使用]]></title>
      <url>%2F2015%2F09%2F20%2FFacebook%20%E5%8A%A8%E7%94%BB%E5%BA%93POP%E4%BD%BF%E7%94%A8%2F</url>
      <content type="text"><![CDATA[POP是Facebook公司的一个开源项目，它是一个完全不同于Core Animation的动画引擎；它在基本的静态动画的基础上增加的弹簧动画与衰减动画 使之能创造出更真实更具物理性的交互动画 POP的API可以快速的与现有的ObjC代码集成并可以作用于任意对象的任意属性，POP是个相当成熟且久经考验的框架，Facebook出品的令人惊叹的Paper应用中的所有动画和效果即出自POP。 使用方式：POP默认支持三种动画 但同时也支持自定义动画 POPBasicAnimation POPSpringAnimation POPDecayAnimation POPCustomAnimation //自定义动画 这里我们只讨论前三种，因为自定义动画还没用过； 代码示例：BasicAnimation let rotation = POPBasicAnimation(propertyNamed: kPOPLayerRotation[^POP动画的参数])rotation.toValue = M_PI * 2rotation.duration = 10rotation.repeatForever = truerotation.timingFunction = CAMediaTimingFunction(name: kCAMediaTimingFunctionLinear) self.layer.pop_addAnimation(rotation, forKey: "旋转") POPBasicAnimation提供四种时间曲线,这个和Core Animation中的是一样的： kCAMediaTimingFunctionLinear kCAMediaTimingFunctionEaseIn kCAMediaTimingFunctionEaseOut kCAMediaTimingFunctionEaseInEaseOut POPSpringAnimation弹性动画 //实例化POPlet scale = POPSpringAnimation(propertyNamed:kPOPViewScaleXY)//设置结束值scale.toValue = NSValue(CGPointMake(2,2))//振幅，范围0-20scale.springBounciness = 20//振动速度,范围0-20scale.springSpeed = 1view.layer.pop_addAnimatiom(scale,foKey:"scale") 弹性动画可配置的属性有： springBounciness:4.0 //[0-20] 弹力 越大则震动幅度越大 springSpeed :12.0 //[0-20] 速度 越大则动画结束越快 dynamicsTension :0 //拉力 下面这三个都跟物理力学模拟相关 数值调整起来很费时，建议就用默认值 dynamicsFriction:0 //摩擦 同上 dynamicsMass :0 //质量 同上 POPDecayAnimation阻尼动画 POPDecayAnimation *anDecay = [POPDecayAnimation animationWithPropertyNamed:kPOPLayerPositionX];anDecay.velocity = @(600);anDecay.beginTime = CACurrentMediaTime() + 1.0f;[self.square pop_addAnimation:anDecay forKey:@"position"]; 注意:这里对POPDecayAnimation设置toValue是没有意义的 会被忽略(因为目的状态是动态计算得到的) POPDecayAnimation可配置的属性与默认值有:deceleration:0.998 //衰减系数(越小则衰减得越快) 注意:POPDecayAnimation也是没有duration字段的 其动画持续时间由velocity与deceleration决定 POP默认支持的动画属性： /** Common CALayer property names. */extern NSString * const kPOPLayerBackgroundColor;extern NSString * const kPOPLayerBounds;extern NSString * const kPOPLayerCornerRadius;extern NSString * const kPOPLayerBorderWidth;extern NSString * const kPOPLayerBorderColor;extern NSString * const kPOPLayerOpacity;extern NSString * const kPOPLayerPosition;extern NSString * const kPOPLayerPositionX;extern NSString * const kPOPLayerPositionY;extern NSString * const kPOPLayerRotation;extern NSString * const kPOPLayerRotationX;extern NSString * const kPOPLayerRotationY;extern NSString * const kPOPLayerScaleX;extern NSString * const kPOPLayerScaleXY;extern NSString * const kPOPLayerScaleY;extern NSString * const kPOPLayerSize;extern NSString * const kPOPLayerSubscaleXY;extern NSString * const kPOPLayerSubtranslationX;extern NSString * const kPOPLayerSubtranslationXY;extern NSString * const kPOPLayerSubtranslationY;extern NSString * const kPOPLayerSubtranslationZ;extern NSString * const kPOPLayerTranslationX;extern NSString * const kPOPLayerTranslationXY;extern NSString * const kPOPLayerTranslationY;extern NSString * const kPOPLayerTranslationZ;extern NSString * const kPOPLayerZPosition;extern NSString * const kPOPLayerShadowColor;extern NSString * const kPOPLayerShadowOffset;extern NSString * const kPOPLayerShadowOpacity;extern NSString * const kPOPLayerShadowRadius;/** Common CAShapeLayer property names. */extern NSString * const kPOPShapeLayerStrokeStart;extern NSString * const kPOPShapeLayerStrokeEnd;extern NSString * const kPOPShapeLayerStrokeColor;extern NSString * const kPOPShapeLayerFillColor;/** Common NSLayoutConstraint property names. */extern NSString * const kPOPLayoutConstraintConstant;#if TARGET_OS_IPHONE/** Common UIView property names. */extern NSString * const kPOPViewAlpha;extern NSString * const kPOPViewBackgroundColor;extern NSString * const kPOPViewBounds;extern NSString * const kPOPViewCenter;extern NSString * const kPOPViewFrame;extern NSString * const kPOPViewScaleX;extern NSString * const kPOPViewScaleXY;extern NSString * const kPOPViewScaleY;extern NSString * const kPOPViewSize;extern NSString * const kPOPViewTintColor;/** Common UIScrollView property names. */extern NSString * const kPOPScrollViewContentOffset;extern NSString * const kPOPScrollViewContentSize;extern NSString * const kPOPScrollViewZoomScale;extern NSString * const kPOPScrollViewContentInset;/** Common UITableView property names. */extern NSString * const kPOPTableViewContentOffset;extern NSString * const kPOPTableViewContentSize;/** Common UICollectionView property names. */extern NSString * const kPOPCollectionViewContentOffset;extern NSString * const kPOPCollectionViewContentSize;/** Common UINavigationBar property names. */extern NSString * const kPOPNavigationBarBarTintColor;/** Common UIToolbar property names. */extern NSString * const kPOPToolbarBarTintColor;/** Common UITabBar property names. */extern NSString * const kPOPTabBarBarTintColor;/** Common UILabel property names. */extern NSString * const kPOPLabelTextColor; 自定义属性：POP默认支持的三种动画都继承自POPPropertyAnimation POPPropertyAnimation中定义了一个叫property的属性( 之前没有用到它是因为POP根据不同的默认动画属性帮你生成了默认的property) 而这个property则是用来驱动POP的动画效果中的重要一环。 POPAnimatableProperty *prop = [POPAnimatableProperty propertyWithName:@"prop" initializer:^(POPMutableAnimatableProperty *prop) &#123; // read value prop.readBlock = ^(id obj, CGFloat values[]) &#123; &#125;; // write value prop.writeBlock = ^(id obj, const CGFloat values[]) &#123; &#125;; // dynamics threshold prop.threshold = 0.01;&#125;]; 其组成就是一个readBlock一个writeBlock和一个threashold readBlock告诉POP当前的属性值 writeBlock中修改变化后的属性值 threashold决定了动画变化间隔的阈值 值越大writeBlock的调用次数越少 POPAnimatableProperty其实是POP中一个比较重要的东西,像上面提到的POP自带的动画属性 查看源代码可以看到也只是POP自动帮你设置好了POPAnimatableProperty而已,其作用就是当动画的某个时间片被触发时,告诉系统如何根据当前时间片做出变化. 下面是一个秒表动画，是利用自定义属性的POP做出来的： POPAnimatableProperty *prop = [POPAnimatableProperty propertyWithName:@"countdown" initializer:^(POPMutableAnimatableProperty *prop) &#123; prop.writeBlock = ^(id obj, const CGFloat values[]) &#123; UILabel *lable = (UILabel*)obj; label.text = [NSString stringWithFormat:@"%02d:%02d:%02d",(int)values[0]/60,(int)values[0]%60,(int)(values[0]*100)%100]; &#125;; // prop.threshold = 0.01f; &#125;]; POPBasicAnimation *anBasic = [POPBasicAnimation linearAnimation]; //秒表当然必须是线性的时间函数 anBasic.property = prop; //自定义属性 anBasic.fromValue = @(0); //从0开始 anBasic.toValue = @(3*60); //180秒 anBasic.duration = 3*60; //持续3分钟 anBasic.beginTime = CACurrentMediaTime() + 1.0f; //延迟1秒开始 [label pop_addAnimation:anBasic forKey:@"countdown"]; 出处：http://adad184.com/2015/03/11/intro-to-pop/]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[SwiftyJSON使用]]></title>
      <url>%2F2015%2F09%2F20%2FSwiftyJSON%E4%BD%BF%E7%94%A8%2F</url>
      <content type="text"><![CDATA[SwiftJSON是用Swift写的一个快速处理JSON数据的第三方库。 使用方法：let json = JSON(data: dataFromNetworking)if let userName = json[&quot;name&quot;].string&#123; //就这么简单取到了。&#125; 中文说明]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[MJRefresh使用]]></title>
      <url>%2F2015%2F09%2F20%2FMJRefresh%E4%BD%BF%E7%94%A8%2F</url>
      <content type="text"><![CDATA[MJRefresh是用法最简单的下拉刷新框架：一行代码搞定 支持 UIScrollView、UITableView、UICollectionView、UIWebView 的刷新 基础用法//设置下拉刷新var MJHeader = MJRefreshNormalHeader(refreshingTarget: self, refreshingAction: "refresh")self.myTabView.header = MJHeader//设置上拉加载var MJFooter = MJRefreshAutoNormalFooter(refreshingTarget: self, refreshingAction: "load")self.myTabView.footer = MJFooterfunc load()&#123; //执行加载动作 self.myTabView.header.endRefreshing()&#125;func refresh()&#123; //执行刷新动作 self.myTabView.footer.endRefreshing()&#125; 高级用法 下拉刷新控件的种类 默认（Normal）：MJRefreshNormalHeader 动图（Gif）：MJRefreshGifHeader 上拉刷新控件的种类 自动刷新（Auto） 默认（Normal）：MJRefreshAutoNormalFooter 动图（Gif）：MJRefreshAutoGifFooter 自动回弹（Back） 默认（Normal）：MJRefreshBackNormalFooter 动图（Gif）：MJRefreshBackGifFooter #### // 设置文字[header setTitle:@"Pull down to refresh" forState:MJRefreshStateIdle];[header setTitle:@"Release to refresh" forState:MJRefreshStatePulling];[header setTitle:@"Loading ..." forState:MJRefreshStateRefreshing];// 设置字体header.stateLabel.font = [UIFont systemFontOfSize:15];header.lastUpdatedTimeLabel.font = [UIFont systemFontOfSize:14];// 设置颜色header.stateLabel.textColor = [UIColor redColor];header.lastUpdatedTimeLabel.textColor = [UIColor blueColor];// 隐藏时间header.lastUpdatedTimeLabel.hidden = YES;// 隐藏状态header.stateLabel.hidden = YES; 下拉加载// 设置回调（一旦进入刷新状态，就调用target的action，也就是调用self的loadMoreData方法）MJRefreshAutoGifFooter *footer = [MJRefreshAutoGifFooter footerWithRefreshingTarget:self refreshingAction:@selector(loadMoreData)];// 设置刷新图片[footer setImages:refreshingImages forState:MJRefreshStateRefreshing];// 隐藏刷新状态的文字footer.refreshingTitleHidden = YES;// 如果没有上面的方法，就用footer.stateLabel.hidden = YES;// 隐藏当前的上拉刷新控件self.tableView.footer.hidden = YES;// 变为没有更多数据的状态[footer noticeNoMoreData];]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Alamofile使用]]></title>
      <url>%2F2015%2F09%2F20%2FAlamofile%E4%BD%BF%E7%94%A8%2F</url>
      <content type="text"><![CDATA[Alamofire 是Swift版的 AFNetworking，是非常方便实用的第三方网络操作框架； 使用方法：Alamofire.request(method: Method, URLString: URLStringConvertible, parameters: [String : AnyObject]?, encoding: ParameterEncoding, headers: [String : String]?).response (options: NSJSONReadingOptions, completionHandler: &#123; (NSURLRequest, NSHTTPURLResponse?, NSData?, NSError?) -&gt; Void in //操作数据&#125;) 但是上面方法中有些参数可以省略，基本用法如下： Alamofire.request(.GET, "URL").responseJSON(options: NSJSONReadingOptions.AllowFragments) &#123; (_, _, json, _) -&gt; Void in //操作数据 &#125; 获取数据的方法 response() responseString(encoding: NSStringEncoding) responseJSON(options: NSJSONReadingOptions) responsePropertyList(options: NSPropertyListReadOptions) HTTP Methodspublic enum Method: String &#123; case OPTIONS = "OPTIONS" case GET = "GET" case HEAD = "HEAD" case POST = "POST" case PUT = "PUT" case PATCH = "PATCH" case DELETE = "DELETE" case TRACE = "TRACE" case CONNECT = "CONNECT"&#125; 请求需要的参数parameters类型是一个字典 [String : AnyObject] let parameters = [ "foo": "bar", "baz": ["a", 1], "qux": ["x": 1 , "y": 2 , "z": 3]]Alamofire.request(.POST, "http://httpbin.org/post", parameters: parameters) 下载文件Alamofire.download(.GET, "http://httpbin.org/stream/100") &#123; temporaryURL, response in let fileManager = NSFileManager.defaultManager() if let directoryURL = fileManager.URLsForDirectory(.DocumentDirectory, inDomains: .UserDomainMask)[0] as? NSURL &#123; let pathComponent = response.suggestedFilename return directoryURL.URLByAppendingPathComponent(pathComponent!) &#125; return temporaryURL&#125; 这些都只是Alamofire的常规使用，更加详细的使用方法其官方网站上有详细描述。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[iOS9 网络https 错误]]></title>
      <url>%2F2015%2F09%2F20%2FiOS9-%E7%BD%91%E7%BB%9Chttps-%E9%94%99%E8%AF%AF%2F</url>
      <content type="text"><![CDATA[在iOS9 中，苹果将原http协议改成了https协议，使用 TLS1.2 SSL加密请求数据。 解决办法： 在info.plist中添加 &lt;key&gt;NSAppTransportSecurity&lt;/key&gt;&lt;dict&gt;&lt;key&gt;NSAllowsArbitraryLoads&lt;/key&gt;&lt;true/&gt;&lt;/dict&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[CocoaPods安装使用方法]]></title>
      <url>%2F2015%2F09%2F20%2FCocoaPods%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%2F</url>
      <content type="text"><![CDATA[安装首先安装好Ruby环境，在终端中输入以下命令： sudo gem install cocoapods 可是在天朝，在终端中敲入这个命令之后，会发现半天没有任何反应。原因无他，因为那堵墙阻挡了cocoapods.org。 我们可以用淘宝的Ruby镜像来访问cocoapods。按照下面的顺序在终端中敲入依次敲入命令： gem sources --remove https://rubygems.org/ 等有反应之后再敲入以下命令: gem sources -a http://ruby.taobao.org/ 为了验证你的Ruby镜像是并且仅是taobao，可以用以下命令查看： gem sources -l 只有在终端中出现下面文字才表明你上面的命令是成功的： CURRENT SOURCES ***http://ruby.taobao.org/ 这时候，再次在终端中运行： sudo gem install cocoapods 等上十几秒钟，CocoaPods就可以在你本地下载并且安装好了，不再需要其他设置。 使用e.g.利用CocaPods安装Alamofire 在终端中进入（cd命令）你项目所在目录，然后在当前目录下，利用vim创建Podfile，运行： vim Podfile 然后在Podfile文件中输入以下文字： source 'https://github.com/CocoaPods/Specs.git'platform :ios, '8.0'use_frameworks!pod 'Alamofire', '~&gt; 2.0' 这段文字可以在Alamofire的GitHub中找到；然后保存退出。vim环境下，保存退出命令是： :wq 然后在终端中的当前项目目录下，运行以下命令： pod install 然后CocoaPods就会帮你做好一切了，使用Alamofire只需要在项目中 import Alamofire； 对了，使用过CocoaPods的项目就不用之前的.xcodeproj文件打开了，而是使用.xcworkspace打开。 在这之后如果你还要添加新的第三方库的话，就只要在已经存在的Podfile中添加相应的代码然后到项目文件夹执行： pod update 快速更新第三方库的方法：在更新时使用如下代码替换之前的 pod update pod update --verbose --no-repo-update]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[NSTimer相关知识]]></title>
      <url>%2F2015%2F09%2F20%2FNSTimer%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%2F</url>
      <content type="text"><![CDATA[定义一个 NSTimer var timer1:NSTimer! = NSTimer.scheduledTimerWithTimeInterval(1, target: self, selector: "addOneMin:", userInfo: nil, repeats: true)//selector 是一个选择器,需要定义一个函数,当函数需要传参时,函数名后应该加冒号 启动 NSTimer .fire() 暂停 .invalidate()]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[iOS MVC 详解]]></title>
      <url>%2F2015%2F09%2F19%2FiOS-MVC-%E8%AF%A6%E8%A7%A3%2F</url>
      <content type="text"><![CDATA[模型-视图-控制器这个模式其实应该叫做MCV，用控制器把model与view隔开才对，也就是model与view互相不知道对方的存在，没有任何瓜葛，他们就像一个团队里吵了架的同事，如果有项目需要他俩来参与，那么最好有第三者来管理他俩之间的沟通与协调。这个第三者就是控制器。既然管理，那么姑且就把这个控制器提做项目经理吧，这样的话让他俩干啥就得干啥。就像斯坦福老头说的视图就是控制器的狗腿子。 让我们来欣赏一下这张图（摘自斯坦福公开课的课件）： 先撇开那些乱七八糟的箭头单看他们之间的分界线，view与controller、model与controller之间的线是虚的，而model与view之间的是双黄线，考过驾照的知道越过这个线意味着什么吧。 控制器与视图之间的大部分连线都可以在Xcode中通过按住ctrl来连接。例如outlet，例如delegate。有了这些连线，他们之间的沟通算是畅通无阻了。 用户在view上的操作可以直接告诉控制器让控制器去响应 view需要的代理也可以指派给控制器让控制器去完成 view需要的数据源也需要控制器来提供 总之，控制器很忙，因为它非常被动。 控制器还需要一个角色的参与：model 顾名思义，模型。我觉得使用asp.net里mvc的domain来描述比较好理解，领域。例如你要开发一个图书管理系统，模型里描绘的就是图书的书名、售价、作者，谁借走了，几号借走的，一切关于这个应用领域的数据。我们可以给模型一个简单的定义：它描述了一个应用所有需要抽象出来的数据结构和这些数据之间的关系，还有他们获取数据需要通过的途径（本地的、远程的）等。有了模型，控制器想啥时候去拿数，想怎么拿都行。 仔细观察上面的图，有控制器到model的箭头，没有model到控制器的箭头。因为模型不需要知道控制器的存在，这样可以减少耦合，提高代码复用可能性。把你定义好的model挪到别的项目中，还可以使用。 但是问题来了，当model数据已经更新了，被修改了，怎么通知相关的控制器？注意model上方有个天线，高端！之所以使用无线的，是因为model不知道更改要发给谁，但是model可以广播，model的观点：谁关心我的更改让谁收听去，我对谁收听了我不感兴趣。 广播的方式有两种：Notification 和 KVO（都是设计模式，本系列接下来会详述） 好了，他们几个之间的关系基本有个概念了。mvc模式就是这样，把原本杂乱无章的类，分为三堆，严格监管，按规则行事。 还是那句话：说到底一切都是为了使类之间的耦合性更松散。好的代码应该对扩展开放，对修改关闭。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Mac终端command not found 解决办法]]></title>
      <url>%2F2015%2F07%2F26%2FMac%E7%BB%88%E7%AB%AF%E6%8F%90%E7%A4%BA-command-not-found%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95%2F</url>
      <content type="text"><![CDATA[在bash_profile中添加： export PATH="$PATH:$HOME/.rvm/bin" # Add RVM to PATH for scripting[[ -s "$HOME/.rvm/scripts/rvm" ]] &amp;&amp; source "$HOME/.rvm/scripts/rvm" # Load RVM into a shell session *as a function*]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[PNChart 使用]]></title>
      <url>%2F2015%2F07%2F21%2FPNChart%20%E4%BD%BF%E7%94%A8%2F</url>
      <content type="text"><![CDATA[PNChart 是一个简约，易用的第三方图表库，它支持折线图，柱形图，饼状图和圆形图的绘制； 使用方法 画折线图 func setLineChart()&#123; /// 定义一个lineChart var lineChart = PNLineChart(frame: CGRectMake(0, self.view.frame.height/4, self.view.frame.width, self.view.frame.height/2)) //不要使用下面的方法，Width 不好计算，只设置数据的话宽度会自动设定 //lineChart.setXLabels([&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;D&quot;,&quot;E&quot;,&quot;F&quot;], withWidth: 50) lineChart.xLabels = [&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;D&quot;,&quot;E&quot;,&quot;F&quot;] lineChart.axisColor = UIColor.blackColor() lineChart.showCoordinateAxis = true /// 设置第一根折线 var dataArray = [1,4,9,20,8,9] var lineChartData = PNLineChartData() //lineChartData.lineWidth = 20 lineChartData.itemCount = UInt(dataArray.count) lineChartData.color = UIColor.greenColor() lineChartData.getData = (&#123;(index:UInt) -&gt; PNLineChartDataItem in var y = dataArray[Int(index)] return PNLineChartDataItem(y: CGFloat(y)) &#125;) //为数据源设置Title lineChartData.dataTitle = &quot;Swift&quot; /// 设置第二根折线 var dataArray2 = [5,19,9,3,5] var lineChartData2 = PNLineChartData() //lineChartData.lineWidth = 20 lineChartData2.itemCount = UInt(dataArray2.count) lineChartData2.color = UIColor.redColor() lineChartData2.getData = (&#123;(index:UInt) -&gt; PNLineChartDataItem in var y = dataArray2[Int(index)] return PNLineChartDataItem(y: CGFloat(y)) &#125;) //把折线加入到lineChart中，开始画图 lineChart.chartData = [lineChartData,lineChartData2] lineChart.strokeChart() self.view.addSubview(lineChart) /// 为图表设置标签，****要在画图之后添加**** //为数据源2设置Title lineChartData2.dataTitle = &quot;OC&quot; //选择标签风格 lineChart.legendStyle = PNLegendItemStyle.Serial //获取标签 var legend = lineChart.getLegendWithMaxWidth(self.view.frame.width) //设置标签位置 legend.frame = CGRectMake(50, lineChart.frame.origin.y + lineChart.frame.height + 10 , legend.frame.width, legend.frame.height) self.view.addSubview(legend) lineChart.delegate = self &#125; 画柱形图： func setBarChart()&#123; //直接初始化一个PNBarChart，不要数据源 var barChart = PNBarChart(frame: CGRectMake(0, 200, self.view.frame.width, 350)) barChart.xLabels = [&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;D&quot;,&quot;E&quot;] //barChart.xLabelWidth = 55 barChart.yValues = [1,3,6,-7,15] //显示图表边界 barChart.showChartBorder = true //允许负数 barChart.showLevelLine = false //barChart.strokeColor = UIColor.redColor() barChart.barRadius = 2 //设置文字颜色，**********设置不了************ barChart.labelTextColor = UIColor.redColor() //开始画图 barChart.strokeChart() self.view.add&#125; 画圆形图： func setCircleChart()&#123; //直接初始化一个PNCircleChart ，不要数据源之类的 var circelChart = PNCircleChart(frame: CGRectMake(self.view.frame.width/2 - self.view.frame.width/4, 200, self.view.frame.width/2, 200), total: 100, current: 60, clockwise: false, shadow: true, shadowColor: UIColor.grayColor()) circelChart.current = 60 circelChart.total = 100 //circelChart.strokeColor = UIColor.greenColor() circelChart.strokeChart() self.view.addSubview(circelChart) &#125; 画饼状图： func setPieChart()&#123; //先定义一个PNPieChartDataItem数组，116 202 33 72 114 224 var items = [PNPieChartDataItem(value: 50, color: UIColor(red: 116/255, green: 202/255, blue: 33/255, alpha: 1) , description: &quot;Swift&quot;),PNPieChartDataItem(value: 20, color: UIColor(red: 72/255, green: 114/255, blue: 224/255, alpha: 1) , description: &quot;OC&quot;)] var pieChart = PNPieChart(frame: CGRectMake(self.view.frame.width/2 - self.view.frame.width/3, 200, self.view.frame.width/1.5, 200), items: items) pieChart.descriptionTextFont = UIFont.systemFontOfSize(15) pieChart.strokeChart() self.view.addSubview(pieChart) //选择标签风格 pieChart.legendStyle = PNLegendItemStyle.Serial //获取标签 var legend = pieChart.getLegendWithMaxWidth(self.view.frame.width) //设置标签位置 legend.frame = CGRectMake(50, pieChart.frame.origin.y + pieChart.frame.height + 10, legend.frame.width, legend.frame.height) self.view.addSubview(legend) &#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[iOSDate相关]]></title>
      <url>%2F2015%2F07%2F20%2FiOS%20Date%E7%9B%B8%E5%85%B3%2F</url>
      <content type="text"><![CDATA[时间和字符串的转换 Data智能转换成字符串，即可以显示“刚刚”，“昨天”，“几小时之前等等” public extension Date &#123; //MARK: 根据规则返回对应的字符串 func getTimeString() -&gt; String &#123; if isToday &#123; if minute &lt; 5 &#123; return "刚刚" &#125; else if hour &lt; 1 &#123; return "\(minute)分钟之前" &#125; else &#123; return "\(hour)小时之前" &#125; &#125; else if isYesterday &#123; return "昨天 \(self.yesterdayTimeStr())" &#125; else if isYear &#123; return noYesterdayTimeStr() &#125; else &#123; return yearTimeStr() &#125; &#125; fileprivate var selfDate : Date &#123; return self &#125; /// 距当前有几分钟 var minute : Int &#123; let dateComponent = Calendar.current.dateComponents([.minute], from: selfDate, to: Date()) return dateComponent.minute! &#125; /// 距当前有几小时 var hour : Int &#123; let dateComponent = Calendar.current.dateComponents([.hour], from: selfDate, to: Date()) return dateComponent.hour! &#125; /// 是否是今天 var isToday : Bool &#123; return Calendar.current.isDateInToday(selfDate) &#125; /// 是否是昨天 var isYesterday : Bool &#123; return Calendar.current.isDateInYesterday(selfDate) &#125; /// 是否是今年 var isYear: Bool &#123; let nowComponent = Calendar.current.dateComponents([.year], from: Date()) let component = Calendar.current.dateComponents([.year], from: selfDate) return (nowComponent.year == component.year) &#125; func yesterdayTimeStr() -&gt; String &#123; let format = DateFormatter() format.dateFormat = "HH:mm" return format.string(from: selfDate) &#125; func noYesterdayTimeStr() -&gt; String &#123; let format = DateFormatter() format.dateFormat = "MM-dd HH:mm" return format.string(from: selfDate) &#125; func yearTimeStr() -&gt; String &#123; let format = DateFormatter() format.dateFormat = "yyyy-MM-dd HH:mm" return format.string(from: selfDate) &#125;&#125; 自带的转换方法，显示今天 xx:xx func dateToString(date:Date) -&gt; String&#123; //定义一个日期格式 let dateFormat = DateFormatter() //日期风格 dateFormat.dateStyle = DateFormatter.Style.short //时间风格 dateFormat.timeStyle = DateFormatter.Style.short //设置相对日期 dateFormat.doesRelativeDateFormatting = true dateFormat.timeStyle = DateFormatter.Style.short //日期的地区为中国 dateFormat.locale = Locale(identifier: "zh_cn") let dateStr = dateFormat.string(from: date) return dateStr&#125; 日期之间比较//与otherDate比较，相同返回YESnow.isEqualToDate(tomorrow)//与anotherDate比较，返回较早的那个日期now.earlierDate(tomorrow)//与anotherDate比较，返回较晚的那个日期now.laterDate(tomorrow)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Next手机代码显示不全解决办法]]></title>
      <url>%2F2015%2F07%2F14%2FNext%E6%89%8B%E6%9C%BA%E4%BB%A3%E7%A0%81%E6%98%BE%E7%A4%BA%E4%B8%8D%E5%85%A8%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95%2F</url>
      <content type="text"><![CDATA[修改custom.styl(路径：source/css/_custom) 增加如下代码： .code &#123;padding-left: 20px !important;background-color: black;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[iOS 传值总结]]></title>
      <url>%2F2015%2F04%2F20%2FiOS-%E4%BC%A0%E5%80%BC%E6%80%BB%E7%BB%93%2F</url>
      <content type="text"><![CDATA[iOS中传值的方式主要有以下几种： segue传值 通知传值 代理传值 单例传值 ShareApplication NSUserdefault 如果是A页面传值到B页面，之间有segue连接的话，用属性传值就可以搞定，如果从B页面传值到A页面或者之间没有直接的segue的话，就可以使用代理传值或者单例传值了。 segue传值 segue传值就是利用segue跳转时利用属性进行传值，这边就不做记录了。 通知传值 通知是一个单例类，只存在一个通知实例，一个通知会有一个对应的名字，而这个名字就是对应的观察者的接受通知的索引，每个对象都可以接收到这个广播，但是只有这个通知的名字和观察者的名字相同时，对应的观察者才可以接收到这个广播并处理对应逻辑。 //seletor: 接收到通知后应该做的操作；name：该通知对应的名字//A发送通知NSNotificationCenter.defaultCenter().postNotificationName(&quot;通知名字&quot;, object: self, userInfo: [&quot;key&quot;: value])//B接收通知NSNotificationCenter.defaultCenter().addObserver(self, selector: &quot;接收到通知后要执行的方法:&quot;, name: &quot;通知名字&quot;, object: nil)//同时实现接受通知后要执行的方法func 接收到通知后要执行的方法(aNotification:NSNotification)&#123; //value = aNotification.userInfo[&quot;key&quot;]&#125;B方 移除监听removeObserver (一定要记得)deinit &#123; NSNotificationCenter.defaultCenter().removeObserver(self)&#125; 代理传值 //声明委托protocol passValueDele&#123; func passValue(value:String)&#125;//接受委托，并定义一个委托类的对象：let vc1 = self.storyboard?.instantiateViewControllerWithIdentifier(&quot;detail&quot;) as! ViewControllervc1.delegate1 = selffunc passValue(value:String)&#123; //得到value之后执行操作&#125;//在委托类中声明一个委托变量，并调用方法传值；weak var delegate1:passValueDele? //注意用weak，防止循环引用delegate1?.passValue(&quot;value&quot;) 单例传值 简单来说单例传值就是创建一个类的单例，各个ViewController共享数据。 先创建一个单例： class SingleTonClass: NSObject &#123; var value:String? struct singleTon &#123; static var once_t:dispatch_once_t = 0 static var currentDataSong:CurrentDataSong? &#125; class func shareCurrentDataSong()-&gt;CurrentDataSong&#123; dispatch_once(&amp;singleTon.once_t) &#123; () -&gt; Void in singleTon.SingleTonClass = SingleTonClass() &#125; return singleTon.SingleTonClass! &#125; &#125; 然后在需要传值的ViewController中给单例的属性赋值；这样就可以在需要值的ViewController中得到要传的值了； ShareAppDelegate传值 和单例的原理一样，不过这个单例利用的是AppDelegate； NSUserdefault传值 此方法试用于轻量级的数据转移，就是把需要传的值先存入到NSUserdefault中，然后在需要值的地方从NSUserdefault中取值。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[iOS HUD]]></title>
      <url>%2F2015%2F03%2F20%2FiOS%20HUD%2F</url>
      <content type="text"><![CDATA[GitHub上iOS关于HUD的第三方库实在太多了， 这三个比较常用： ProgressHUD SwiftNotice MBProgressHUD ProgressHUD用法简单，一行代码搞定： #import "ProgressHUD.h"ProgressHUD.show("正在刷新！")ProgressHUD.showError("错误")ProgressHUD.showSuccess("刷新成功！")ProgressHUD.dismiss() 但是可自定义的属性不多； SwiftNotice用法同样简单，还支持顶部通知： noticeTop("") //顶部通知notice("", type: NoticeType, autoClear: true)noticeOnlyText("")successNotice("")errorNotice("") MBProgressHUD[MBProgressHUD showHUDAddedTo:self.view animated:YES];dispatch_async(dispatch_get_global_queue( DISPATCH_QUEUE_PRIORITY_LOW, 0), ^&#123; // Do something... dispatch_async(dispatch_get_main_queue(), ^&#123; [MBProgressHUD hideHUDForView:self.view animated:YES]; &#125;);&#125;); 自定义： MBProgressHUD *hud = [MBProgressHUD showHUDAddedTo:self.view animated:YES];hud.mode = MBProgressHUDModeAnnularDeterminate;hud.labelText = @"Loading";[self doSomethingInBackgroundWithProgressCallback:^(float progress) &#123; hud.progress = progress;&#125; completionCallback:^&#123; [hud hide:YES];&#125;];]]></content>
    </entry>

    
  
  
</search>
