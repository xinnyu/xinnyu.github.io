<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[iOS小Tips]]></title>
      <url>%2Farchives%2F2017%2F04%2F27%2FiOS%E5%B0%8FTips%2F</url>
      <content type="text"><![CDATA[1，打印View所有子视图po [[self view]recursiveDescription] 2，layoutSubviews调用的调用时机* 当视图第一次显示的时候会被调用。* 添加子视图也会调用这个方法。* 当本视图的大小发生改变的时候是会调用的。* 当子视图的frame发生改变的时候是会调用的。* 当删除子视图的时候是会调用的. 3，NSString过滤特殊字符// 定义一个特殊字符的集合NSCharacterSet *set = [NSCharacterSet characterSetWithCharactersInString:@"@／：；（）¥「」＂、[]&#123;&#125;#%-*+=_\\|~＜＞$€^•'@#$%^&amp;*()_+'\""];// 过滤字符串的特殊字符NSString *newString = [trimString stringByTrimmingCharactersInSet:set]; 4，TransForm属性//平移按钮CGAffineTransform transForm = self.buttonView.transform;self.buttonView.transform = CGAffineTransformTranslate(transForm, 10, 0);//旋转按钮CGAffineTransform transForm = self.buttonView.transform;self.buttonView.transform = CGAffineTransformRotate(transForm, M_PI_4);//缩放按钮self.buttonView.transform = CGAffineTransformScale(transForm, 1.2, 1.2);//初始化复位self.buttonView.transform = CGAffineTransformIdentity; 5，去掉分割线多余15像素//首先在viewDidLoad方法加入以下代码：if ([self.tableView respondsToSelector:@selector(setSeparatorInset:)]) &#123; [self.tableView setSeparatorInset:UIEdgeInsetsZero]; &#125; if ([self.tableView respondsToSelector:@selector(setLayoutMargins:)]) &#123; [self.tableView setLayoutMargins:UIEdgeInsetsZero];&#125;//然后在重写willDisplayCell方法- (void)tableView:(UITableView *)tableView willDisplayCell:(UITableViewCell *)cell forRowAtIndexPath:(NSIndexPath *)indexPath&#123; if ([cell respondsToSelector:@selector(setSeparatorInset:)]) &#123; [cell setSeparatorInset:UIEdgeInsetsZero]; &#125; if ([cell respondsToSelector:@selector(setLayoutMargins:)]) &#123; [cell setLayoutMargins:UIEdgeInsetsZero]; &#125;&#125; 6，计算方法耗时时间间隔// 获取时间间隔#define TICK CFAbsoluteTime start = CFAbsoluteTimeGetCurrent();#define TOCK NSLog(@"Time: %f", CFAbsoluteTimeGetCurrent() - start) 7，Color颜色宏定义// 随机颜色#define RANDOM_COLOR [UIColor colorWithRed:arc4random_uniform(256) / 255.0 green:arc4random_uniform(256) / 255.0 blue:arc4random_uniform(256) / 255.0 alpha:1]// 颜色(RGB)#define RGBCOLOR(r, g, b) [UIColor colorWithRed:(r)/255.0f green:(g)/255.0f blue:(b)/255.0f alpha:1]// 利用这种方法设置颜色和透明值，可不影响子视图背景色#define RGBACOLOR(r, g, b, a) [UIColor colorWithRed:(r)/255.0f green:(g)/255.0f blue:(b)/255.0f alpha:(a)] 8，让 iOS 应用直接退出- (void)exitApplication &#123; AppDelegate *app = [UIApplication sharedApplication].delegate; UIWindow *window = app.window; [UIView animateWithDuration:1.0f animations:^&#123; window.alpha = 0; &#125; completion:^(BOOL finished) &#123; exit(0); &#125;];&#125; 9，修改Label中不同文字颜色- (void)touchesEnded:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event&#123; [self editStringColor:self.label.text editStr:@"好" color:[UIColor blueColor]];&#125;- (void)editStringColor:(NSString *)string editStr:(NSString *)editStr color:(UIColor *)color &#123; // string为整体字符串, editStr为需要修改的字符串 NSRange range = [string rangeOfString:editStr]; NSMutableAttributedString *attribute = [[NSMutableAttributedString alloc] initWithString:string]; // 设置属性修改字体颜色UIColor与大小UIFont [attribute addAttributes:@&#123;NSForegroundColorAttributeName:color&#125; range:range]; self.label.attributedText = attribute;&#125; 10，播放声音#import&lt;AVFoundation/AVFoundation.h&gt;// 1.获取音效资源的路径 NSString *path = [[NSBundle mainBundle]pathForResource:@"pour_milk" ofType:@"wav"];// 2.将路劲转化为url NSURL *tempUrl = [NSURL fileURLWithPath:path];// 3.用转化成的url创建一个播放器 NSError *error = nil; AVAudioPlayer *play = [[AVAudioPlayer alloc]initWithContentsOfURL:tempUrl error:&amp;error]; self.player = play;// 4.播放[play play]; 11，修改Tabbar Item的属性// 修改标题位置self.tabBarItem.titlePositionAdjustment = UIOffsetMake(0, -10);// 修改图片位置self.tabBarItem.imageInsets = UIEdgeInsetsMake(-3, 0, 3, 0);// 批量修改属性for (UIBarItem *item in self.tabBarController.tabBar.items) &#123; [item setTitleTextAttributes:[NSDictionary dictionaryWithObjectsAndKeys: [UIFont fontWithName:@"Helvetica" size:19.0], NSFontAttributeName, nil] forState:UIControlStateNormal];&#125;// 设置选中和未选中字体颜色[[UITabBar appearance] setShadowImage:[[UIImage alloc] init]];//未选中字体颜色[[UITabBarItem appearance] setTitleTextAttributes:@&#123;NSForegroundColorAttributeName:[UIColor greenColor]&#125; forState:UIControlStateNormal];//选中字体颜色[[UITabBarItem appearance] setTitleTextAttributes:@&#123;NSForegroundColorAttributeName:[UIColor cyanColor]&#125; forState:UIControlStateSelected];//去掉BackBarButtonItem的文字[[UIBarButtonItem appearance] setBackButtonTitlePositionAdjustment:UIOffsetMake(0, -60) forBarMetrics:UIBarMetricsDefault]; 12，NULL - nil - Nil - NSNULL的区别* nil是OC的，空对象，地址指向空（0）的对象。对象的字面零值* Nil是Objective-C类的字面零值* NULL是C的，空地址，地址的数值是0，是个长整数* NSNull用于解决向NSArray和NSDictionary等集合中添加空值的问题 13，修改UITextField中Placeholder的文字颜色[text setValue:[UIColor redColor] forKeyPath:@"_placeholderLabel.textColor"]; 14，生命周期1、 alloc 创建对象，分配空间2、 init (initWithNibName) 初始化对象，初始化数据3、 loadView 从nib载入视图 ，除非你没有使用xib文件创建视图4、 viewDidLoad 载入完成，可以进行自定义数据以及动态创建其他控件5、 viewWillAppear视图将出现在屏幕之前，马上这个视图就会被展现在屏幕上了6、 viewDidAppear 视图已在屏幕上渲染完成1、viewWillDisappear 视图将被从屏幕上移除之前执行2、viewDidDisappear 视图已经被从屏幕上移除，用户看不到这个视图了3、dealloc 视图被销毁，此处需要对你在init和viewDidLoad中创建的对象进行释放.viewVillUnload－ 当内存过低，即将释放时调用；viewDidUnload－当内存过低，释放一些不需要的视图时调用。*应用程序的生命周期:1，启动但还没进入状态保存 ：- (BOOL)application:(UIApplication *)application willFinishLaunchingWithOptions:(NSDictionary *)launchOptions 2，基本完成程序准备开始运行：- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions 3，当应用程序将要入非活动状态执行，应用程序不接收消息或事件，比如来电话了：- (void)applicationWillResignActive:(UIApplication *)application 4，当应用程序入活动状态执行，这个刚好跟上面那个方法相反：- (void)applicationDidBecomeActive:(UIApplication *)application 5，当程序被推送到后台的时候调用。所以要设置后台继续运行，则在这个函数里面设置即可：- (void)applicationDidEnterBackground:(UIApplication *)application 6，当程序从后台将要重新回到前台时候调用，这个刚好跟上面的那个方法相反：- (void)applicationWillEnterForeground:(UIApplication *)application 7，当程序将要退出是被调用，通常是用来保存数据和一些退出前的清理工作：- (void)applicationWillTerminate:(UIApplication *)application 15，判断view是不是指定视图的子视图BOOL isView = [textView isDescendantOfView:self.view]; 16，判断对象是否遵循了某协议if ([self.selectedController conformsToProtocol:@protocol(RefreshPtotocol)]) &#123; [self.selectedController performSelector:@selector(onTriggerRefresh)];&#125; 17，页面强制横屏#pragma mark - 强制横屏代码- (BOOL)shouldAutorotate&#123; //是否支持转屏 return NO;&#125;- (UIInterfaceOrientationMask)supportedInterfaceOrientations&#123; //支持哪些转屏方向 return UIInterfaceOrientationMaskLandscape;&#125;- (UIInterfaceOrientation)preferredInterfaceOrientationForPresentation&#123; return UIInterfaceOrientationLandscapeRight;&#125;- (BOOL)prefersStatusBarHidden&#123; return NO;&#125; 18，系统键盘通知消息1、UIKeyboardWillShowNotification-将要弹出键盘2、UIKeyboardDidShowNotification-显示键盘3、UIKeyboardWillHideNotification-将要隐藏键盘4、UIKeyboardDidHideNotification-键盘已经隐藏5、UIKeyboardWillChangeFrameNotification-键盘将要改变frame6、UIKeyboardDidChangeFrameNotification-键盘已经改变frame 19，关闭navigationController的滑动返回手势self.navigationController.interactivePopGestureRecognizer.enabled = NO; 20，设置状态栏背景为任意的颜色- (void)setStatusColor&#123; UIView *statusBarView = [[UIView alloc] initWithFrame:CGRectMake(0, 0,[UIScreen mainScreen].bounds.size.width, 20)]; statusBarView.backgroundColor = [UIColor orangeColor]; [self.view addSubview:statusBarView];&#125; 21，让Xcode的控制台支持LLDB类型的打印打开终端输入三条命令:touch ~/.lldbinitecho display @import UIKit &gt;&gt; ~/.lldbinitecho target stop-hook add -o \"target stop-hook disable\" &gt;&gt; ~/.lldbinit 22，Label行间距-（void）test&#123; NSMutableAttributedString *attributedString = [[NSMutableAttributedString alloc] initWithString:self.contentLabel.text]; NSMutableParagraphStyle *paragraphStyle = [[NSMutableParagraphStyle alloc] init]; [paragraphStyle setLineSpacing:3]; //调整行间距 [attributedString addAttribute:NSParagraphStyleAttributeName value:paragraphStyle range:NSMakeRange(0, [self.contentLabel.text length])]; self.contentLabel.attributedText = attributedString;&#125; 23，UIImageView填充模式@"UIViewContentModeScaleToFill", // 拉伸自适应填满整个视图 @"UIViewContentModeScaleAspectFit", // 自适应比例大小显示 @"UIViewContentModeScaleAspectFill", // 原始大小显示 @"UIViewContentModeRedraw", // 尺寸改变时重绘 @"UIViewContentModeCenter", // 中间 @"UIViewContentModeTop", // 顶部 @"UIViewContentModeBottom", // 底部 @"UIViewContentModeLeft", // 中间贴左 @"UIViewContentModeRight", // 中间贴右 @"UIViewContentModeTopLeft", // 贴左上 @"UIViewContentModeTopRight", // 贴右上 @"UIViewContentModeBottomLeft", // 贴左下 @"UIViewContentModeBottomRight", // 贴右下 24，宏定义检测block是否可用#define BLOCK_EXEC(block, ...) if (block) &#123; block(__VA_ARGS__); &#125;; // 宏定义之前的用法 if (completionBlock) &#123; completionBlock(arg1, arg2); &#125; // 宏定义之后的用法BLOCK_EXEC(completionBlock, arg1, arg2); 25，设置状态栏文字样式颜色[[UIApplication sharedApplication] setStatusBarHidden:NO];[[UIApplication sharedApplication] setStatusBarStyle:UIStatusBarStyleLightContent]; *26，iOS中的一些手势轻击手势（TapGestureRecognizer）轻扫手势（SwipeGestureRecognizer）长按手势（LongPressGestureRecognizer）拖动手势（PanGestureRecognizer）捏合手势（PinchGestureRecognizer）旋转手势（RotationGestureRecognizer） 27，iOS 开发中一些相关的路径模拟器的位置:/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs 文档安装位置:/Applications/Xcode.app/Contents/Developer/Documentation/DocSets插件保存路径:~/Library/ApplicationSupport/Developer/Shared/Xcode/Plug-ins自定义代码段的保存路径:~/Library/Developer/Xcode/UserData/CodeSnippets/ 如果找不到CodeSnippets文件夹，可以自己新建一个CodeSnippets文件夹。证书路径~/Library/MobileDevice/Provisioning Profiles 28，获取 iOS 路径的方法获取用户目录路径的函数NSString *homeDir = NSHomeDirectory();获取Documents目录路径的方法NSArray *paths = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES);NSString *docDir = [paths objectAtIndex:0];获取Cache目录路径的方法NSArray *paths = NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES);NSString *cachesDir = [paths objectAtIndex:0];获取tmp目录路径的方法：NSString *tmpDir = NSTemporaryDirectory(); 29，字符串相关操作去除所有的空格[str stringByReplacingOccurrencesOfString:@" " withString:@""]去除首尾的空格[str stringByTrimmingCharactersInSet:[NSCharacterSet whitespaceCharacterSet]];- (NSString *)uppercaseString; 全部字符转为大写字母- (NSString *)lowercaseString 全部字符转为小写字母 30， CocoaPods pod install/pod update更新慢的问题pod install --verbose --no-repo-update pod update --verbose --no-repo-update如果不加后面的参数，默认会升级CocoaPods的spec仓库，加一个参数可以省略这一步，然后速度就会提升不少。 31，MRC和ARC混编设置方式在XCode中targets的build phases选项下Compile Sources下选择 不需要arc编译的文件双击输入 -fno-objc-arc 即可MRC工程中也可以使用ARC的类，方法如下：在XCode中targets的build phases选项下Compile Sources下选择要使用arc编译的文件双击输入 -fobjc-arc 即可 32，把tableview里cell的小对勾的颜色改成别的颜色_mTableView.tintColor = [UIColor redColor]; 33，调整tableview的separaLine线的位置tableView.separatorInset = UIEdgeInsetsMake(0, 100, 0, 0); 34，设置滑动的时候隐藏navigationbarnavigationController.hidesBarsOnSwipe = Yes 35，自动处理键盘事件，实现输入框防遮挡的插件**IQKeyboardManagerhttps://github.com/hackiftekhar/IQKeyboardManager 36，Quartz2D相关图形上下文是一个CGContextRef类型的数据。图形上下文包含：1，绘图路径（各种各样图形）2，绘图状态（颜色，线宽，样式，旋转，缩放，平移）3，输出目标（绘制到什么地方去？UIView、图片）1，获取当前图形上下文CGContextRef ctx = UIGraphicsGetCurrentContext();2，添加线条CGContextMoveToPoint(ctx, 20, 20);3，渲染CGContextStrokePath(ctx);CGContextFillPath(ctx);4，关闭路径CGContextClosePath(ctx);5，画矩形CGContextAddRect(ctx, CGRectMake(20, 20, 100, 120));6，设置线条颜色[[UIColor redColor] setStroke];7， 设置线条宽度CGContextSetLineWidth(ctx, 20);8，设置头尾样式CGContextSetLineCap(ctx, kCGLineCapSquare);9，设置转折点样式CGContextSetLineJoin(ctx, kCGLineJoinBevel);10，画圆CGContextAddEllipseInRect(ctx, CGRectMake(30, 50, 100, 100));11，指定圆心CGContextAddArc(ctx, 100, 100, 50, 0, M_PI * 2, 1);12，获取图片上下文UIGraphicsGetImageFromCurrentImageContext();13，保存图形上下文CGContextSaveGState(ctx)14，恢复图形上下文CGContextRestoreGState(ctx) 37，屏幕截图// 1. 开启一个与图片相关的图形上下文UIGraphicsBeginImageContextWithOptions(self.view.bounds.size,NO,0.0);// 2. 获取当前图形上下文CGContextRef ctx = UIGraphicsGetCurrentContext();// 3. 获取需要截取的view的layer[self.view.layer renderInContext:ctx];// 4. 从当前上下文中获取图片UIImage *image = UIGraphicsGetImageFromCurrentImageContext();// 5. 关闭图形上下文UIGraphicsEndImageContext();// 6. 把图片保存到相册UIImageWriteToSavedPhotosAlbum(image, nil, nil, nil); 37，左右抖动动画//1, 创建核心动画CAKeyframeAnimation *keyAnima = [CAKeyframeAnimation animation]; //2, 告诉系统执行什么动画。keyAnima.keyPath = @"transform.rotation"; keyAnima.values = @[@(-M_PI_4 /90.0 * 5),@(M_PI_4 /90.0 * 5),@(-M_PI_4 /90.0 * 5)]; // 3, 执行完之后不删除动画 keyAnima.removedOnCompletion = NO; // 4, 执行完之后保存最新的状态 keyAnima.fillMode = kCAFillModeForwards; // 5, 动画执行时间 keyAnima.duration = 0.2; // 6, 设置重复次数。 keyAnima.repeatCount = MAXFLOAT; // 7, 添加核心动画 [self.iconView.layer addAnimation:keyAnima forKey:nil]; 38，CALayer 的知识CALayer 负责视图中显示内容和动画UIView 负责监听和响应事件创建UIView对象时，UIView内部会自动创建一个图层（既CALayer）UIView本身不具备显示的功能，是它内部的层才有显示功能.CALayer属性：position 中点（由anchorPoint决定）anchorPoint 锚点borderColor 边框颜色borderWidth 边框宽度cornerRadius 圆角半径shadowColor 阴影颜色contents 内容opacity 透明度shadowOpacity 偏移shadowRadius 阴影半径shadowColor 阴影颜色masksToBounds 裁剪 39，性能相关1. 视图复用,比如UITableViewCell,UICollectionViewCell.2. 数据缓存,比如用SDWebImage实现图片缓存。3. 任何情况下都不能堵塞主线程，把耗时操作尽量放到子线程。4. 如果有多个下载同时并发，可以控制并发数。5. 在合适的地方尽量使用懒加载。6. 重用重大开销对象，比如：NSDateFormatter、NSCalendar。7. 选择合适的数据存储。8. 避免循环引用。避免delegate用retain、strong修饰，block可能导致循环引用，NSTimer也可能导致内存泄露等。9. 当涉及到定位的时候，不用的时候最好把定位服务关闭。因为定位耗电、流量。10. 加锁对性能有重大开销。11. 界面最好不要添加过多的subViews.12. TableView 如果不同行高，那么返回行高，最好做缓存。13. Viewdidload 里尽量不要做耗时操作。 40，验证身份证号码//验证身份证号码- (BOOL)checkIdentityCardNo:(NSString*)cardNo&#123; if (cardNo.length != 18) &#123; return NO; &#125; NSArray* codeArray = [NSArray arrayWithObjects:@"7",@"9",@"10",@"5",@"8",@"4",@"2",@"1",@"6",@"3",@"7",@"9",@"10",@"5",@"8",@"4",@"2", nil]; NSDictionary* checkCodeDic = [NSDictionary dictionaryWithObjects:[NSArray arrayWithObjects:@"1",@"0",@"X",@"9",@"8",@"7",@"6",@"5",@"4",@"3",@"2", nil] forKeys:[NSArray arrayWithObjects:@"0",@"1",@"2",@"3",@"4",@"5",@"6",@"7",@"8",@"9",@"10", nil]]; NSScanner* scan = [NSScanner scannerWithString:[cardNo substringToIndex:17]]; int val; BOOL isNum = [scan scanInt:&amp;val] &amp;&amp; [scan isAtEnd]; if (!isNum) &#123; return NO; &#125; int sumValue = 0; for (int i =0; i&lt;17; i++) &#123; sumValue+=[[cardNo substringWithRange:NSMakeRange(i , 1) ] intValue]* [[codeArray objectAtIndex:i] intValue]; &#125; NSString* strlast = [checkCodeDic objectForKey:[NSString stringWithFormat:@"%d",sumValue%11]]; if ([strlast isEqualToString: [[cardNo substringWithRange:NSMakeRange(17, 1)]uppercaseString]]) &#123; return YES; &#125; return NO;&#125; 41，响应者链条顺序1&gt; 当应用程序启动以后创建 UIApplication 对象2&gt; 然后启动“消息循环”监听所有的事件3&gt; 当用户触摸屏幕的时候, "消息循环"监听到这个触摸事件4&gt; "消息循环" 首先把监听到的触摸事件传递了 UIApplication 对象5&gt; UIApplication 对象再传递给 UIWindow 对象6&gt; UIWindow 对象再传递给 UIWindow 的根控制器(rootViewController)7&gt; 控制器再传递给控制器所管理的 view8&gt; 控制器所管理的 View 在其内部搜索看本次触摸的点在哪个控件的范围内（调用Hit test检测是否在这个范围内）9&gt; 找到某个控件以后(调用这个控件的 touchesXxx 方法), 再一次向上返回, 最终返回给"消息循环"10&gt; "消息循环"知道哪个按钮被点击后, 在搜索这个按钮是否注册了对应的事件, 如果注册了, 那么就调用这个"事件处理"程序。（一般就是执行控制器中的"事件处理"方法） 42，使用函数式指针执行方法和忽略performSelector方法的时候警告//不带参数的：SEL selector = NSSelectorFromString(@"someMethod");IMP imp = [_controller methodForSelector:selector];void (*func)(id, SEL) = (void *)imp;func(_controller, selector);//带参数的：SEL selector = NSSelectorFromString(@"processRegion:ofView:");IMP imp = [_controller methodForSelector:selector];CGRect (*func)(id, SEL, CGRect, UIView *) = (void *)imp;CGRect result = func(_controller, selector, someRect, someView);//忽略警告：#pragma clang diagnostic push #pragma clang diagnostic ignored "-Warc-performSelector-leaks"[someController performSelector: NSSelectorFromString(@"someMethod")]#pragma clang diagnostic pop//如果需要忽视的警告有多处，可以定义一个宏：#define SuppressPerformSelectorLeakWarning(Stuff) \ do &#123;\ _Pragma("clang diagnostic push") \ _Pragma("clang diagnostic ignored \"-Warc-performSelector-leaks\"") \Stuff; \_Pragma("clang diagnostic pop") \ &#125; while (0)//使用方法：SuppressPerformSelectorLeakWarning( [_target performSelector:_action withObject:self]); 43，UIApplication的简单使用//--------设置角标数字--------//获取UIApplication对象 UIApplication *ap = [UIApplication sharedApplication];//在设置之前, 要注册一个通知,从ios8之后,都要先注册一个通知对象.才能够接收到提醒. UIUserNotificationSettings *notice = [UIUserNotificationSettings settingsForTypes:UIUserNotificationTypeBadge categories:nil];//注册通知对象 [ap registerUserNotificationSettings:notice];//设置提醒数字 ap.applicationIconBadgeNumber = 20;//--------设置联网状态--------UIApplication *ap = [UIApplication sharedApplication];ap.networkActivityIndicatorVisible = YES; 44, UITableView隐藏空白部分线条self.tableView.tableFooterView = [[UIView alloc]init]; 45，显示git增量的Xcode插件：GitDiff下载地址：https://github.com/johnno1962/GitDiff这款插件的名字是GitDiff，作用就是可以显示表示出git增量提交的代码行,会在Xcode左边标识出来 46，各种收藏的网址unicode编码转换http://tool.chinaz.com/tools/unicode.aspx JSON 字符串格式化http://www.runoob.com/jsontoolRGB 颜色值转换http://www.sioe.cn/yingyong/yanse-rgb-16/短网址生成http://dwz.wailian.work/MAC 软件下载http://www.waitsun.com/objc 中国http://objccn.io/ 47，NSObject 继承图 48，浅拷贝、深拷贝、copy和strong浅拷贝：（任何一方的变动都会影响到另一方）只是对对象的简单拷贝，让几个对象共用一片内存，当内存销毁的时候，指向这片内存的几个指针需要重新定义才可以使用。深拷贝：（任何一方的变动都不会影响到另一方）拷贝对象的具体内容，内存地址是自主分配的，拷贝结束后，两个对象虽然存的值是相同的，但是内存地址不一样，两个对象也互不影响，互不干涉。copy和Strong的区别：copy是创建一个新对象，Strong是创建一个指针。 49，SEL 和 IMPSEL: 其实是对方法的一种包装,将方法包装成一个SEL类型的数据,去寻找对应的方法地址,找到方法地址后就可以调用方法。这些都是运行时特性,发消息就是发送SEL,然后根据SEL找到地址,调用方法。IMP: 是”implementation”的缩写,它是objetive-C 方法 (method)实现代码块的地址,类似函数指针,通过它可以 直接访问任意一个方法。免去发送消息的代价。 50, self 和 super在动态方法中，self代表着"对象"在静态方法中，self代表着"类"万变不离其宗，记住一句话就行了：self代表着当前方法的调用者self 和 super 是oc提供的 两个保留字, 但有根本区别，self是类的隐藏的参数变量,指向当前调用方法的对象（类也是对象，类对象）另一个隐藏参数是_cmd，代表当前类方法的selector。super并不是隐藏的参数,它只是一个"编译器指示符"super 就是个障眼法 发，编译器符号， 它可以替换成 [self class],只不过 方法是从 self 的超类开始寻找。 51, 长连接 和 短连接长连接：（长连接在没有数据通信时，定时发送数据包(心跳)，以维持连接状态）连接→数据传输→保持连接(心跳)→数据传输→保持连接(心跳)→……→关闭连接； 长连接：连接服务器就不断开短连接：（短连接在没有数据传输时直接关闭就行了）连接→数据传输→关闭连接；短连接：连接上服务器，获取完数据，就立即断开。 52, HTTP 基本状态码200 OK请求已成功，请求所希望的响应头或数据体将随此响应返回。300 Multiple Choices被请求的资源有一系列可供选择的回馈信息，每个都有自己特定的地址和浏览器驱动的商议信息。用户或浏览器能够自行选择一个首选的地址进行重定向。400 Bad Request由于包含语法错误，当前请求无法被服务器理解。除非进行修改，否则客户端不应该重复提交这个请求。404 Not Found请求失败，请求所希望得到的资源未被在服务器上发现。没有信息能够告诉用户这个状况到底是暂时的还是永久的。假如服务器知道情况的话，应当使用410状态码来告知旧资源因为某些内部的配置机制问题，已经永久的不可用，而且没有任何可以跳转的地址。404这个状态码被广泛应用于当服务器不想揭示到底为何请求被拒绝或者没有其他适合的响应可用的情况下。408 Request Timeout请求超时。客户端没有在服务器预备等待的时间内完成一个请求的发送。客户端可以随时再次提交这一请求而无需进行任何更改。500 Internal Server Error服务器遇到了一个未曾预料的状况，导致了它无法完成对请求的处理。一般来说，这个问题都会在服务器的程序码出错时出现。 53, TCP 和 UDPTCP：- 建立连接，形成传输数据的通道- 在连接中进行大数据传输（数据大小受限制）- 通过三次握手完成连接，是可靠协议- 必须建立连接，效率比UDP低UDP:- 只管发送，不管接受- 将数据以及源和目的封装成数据包中，不需要建立连接、- 每个数据报的大小限制在64K之内- 不可靠协议- 速度快 54, 三次握手和四次断开三次握手：你在吗-我在的-我问你个事情四次断开握手我这个问题问完了--你问完了吗---可以下线了吗---我真的问完了拜拜 55, 设置按钮按下时候高亮button.showsTouchWhenHighlighted=YES; 56, ScrollView莫名其妙不能在viewController划到顶怎么办？self.automaticallyAdjustsScrollViewInsets = NO; 57，复制字符串到iOS剪贴板UIPasteboard *pasteboard = [UIPasteboard generalPasteboard];pasteboard.string = self.label.text; 58，线程租调度事例// 群组－统一监控一组任务dispatch_group_t group = dispatch_group_create();dispatch_queue_t q = dispatch_get_global_queue(0, 0);// 添加任务// group 负责监控任务，queue 负责调度任务dispatch_group_async(group, q, ^&#123;[NSThread sleepForTimeInterval:1.0];NSLog(@"任务1 %@", [NSThread currentThread]);&#125;);dispatch_group_async(group, q, ^&#123;NSLog(@"任务2 %@", [NSThread currentThread]);&#125;);dispatch_group_async(group, q, ^&#123;NSLog(@"任务3 %@", [NSThread currentThread]);&#125;);// 监听所有任务完成 － 等到 group 中的所有任务执行完毕后，"由队列调度 block 中的任务异步执行！"dispatch_group_notify(group, dispatch_get_main_queue(), ^&#123;// 修改为主队列，后台批量下载，结束后，主线程统一更新UINSLog(@"OK %@", [NSThread currentThread]);&#125;);NSLog(@"come here"); 59、视图坐标转换// 将像素point由point所在视图转换到目标视图view中，返回在目标视图view中的像素值- (CGPoint)convertPoint:(CGPoint)point toView:(UIView *)view;// 将像素point从view中转换到当前视图中，返回在当前视图中的像素值- (CGPoint)convertPoint:(CGPoint)point fromView:(UIView *)view;// 将rect由rect所在视图转换到目标视图view中，返回在目标视图view中的rect- (CGRect)convertRect:(CGRect)rect toView:(UIView *)view;// 将rect从view中转换到当前视图中，返回在当前视图中的rect- (CGRect)convertRect:(CGRect)rect fromView:(UIView *)view;// 例把UITableViewCell中的subview(btn)的frame转换到controllerA中// controllerA 中有一个UITableView, UITableView里有多行UITableVieCell，cell上放有一个button// 在controllerA中实现:CGRect rc = [cell convertRect:cell.btn.frame toView:self.view];//或CGRect rc = [self.view convertRect:cell.btn.frame fromView:cell];// 此rc为btn在controllerA中的rect//或当已知btn时：CGRect rc = [btn.superview convertRect:btn.frame toView:self.view];//或CGRect rc = [self.view convertRect:btn.frame fromView:btn.superview]; 60、设置animation动画终了，不返回初始状态animation.removedOnCompletion = NO;animation.fillMode = kCAFillModeForwards; 61、UIViewAnimationOptions类型1.常规动画属性设置（可以同时选择多个进行设置）UIViewAnimationOptionLayoutSubviews：动画过程中保证子视图跟随运动。UIViewAnimationOptionAllowUserInteraction：动画过程中允许用户交互。UIViewAnimationOptionBeginFromCurrentState：所有视图从当前状态开始运行。UIViewAnimationOptionRepeat：重复运行动画。UIViewAnimationOptionAutoreverse ：动画运行到结束点后仍然以动画方式回到初始点。UIViewAnimationOptionOverrideInheritedDuration：忽略嵌套动画时间设置。UIViewAnimationOptionOverrideInheritedCurve：忽略嵌套动画速度设置。UIViewAnimationOptionAllowAnimatedContent：动画过程中重绘视图（注意仅仅适用于转场动画）。 UIViewAnimationOptionShowHideTransitionViews：视图切换时直接隐藏旧视图、显示新视图，而不是将旧视图从父视图移除（仅仅适用于转场动画）UIViewAnimationOptionOverrideInheritedOptions ：不继承父动画设置或动画类型。2.动画速度控制（可从其中选择一个设置）UIViewAnimationOptionCurveEaseInOut：动画先缓慢，然后逐渐加速。UIViewAnimationOptionCurveEaseIn ：动画逐渐变慢。UIViewAnimationOptionCurveEaseOut：动画逐渐加速。UIViewAnimationOptionCurveLinear ：动画匀速执行，默认值。3.转场类型（仅适用于转场动画设置，可以从中选择一个进行设置，基本动画、关键帧动画不需要设置）UIViewAnimationOptionTransitionNone：没有转场动画效果。UIViewAnimationOptionTransitionFlipFromLeft ：从左侧翻转效果。UIViewAnimationOptionTransitionFlipFromRight：从右侧翻转效果。UIViewAnimationOptionTransitionCurlUp：向后翻页的动画过渡效果。 UIViewAnimationOptionTransitionCurlDown ：向前翻页的动画过渡效果。 UIViewAnimationOptionTransitionCrossDissolve：旧视图溶解消失显示下一个新视图的效果。 UIViewAnimationOptionTransitionFlipFromTop ：从上方翻转效果。 UIViewAnimationOptionTransitionFlipFromBottom：从底部翻转效果。 62、获取当前View所在的控制器/** 获取当前View所在的控制器*/-(UIViewController *)getCurrentViewController&#123; UIResponder *next = [self nextResponder]; do &#123; if ([next isKindOfClass:[UIViewController class]]) &#123; return (UIViewController *)next; &#125; next = [next nextResponder]; &#125; while (next != nil); return nil;&#125; 63、iOS横向滚动的scrollView和系统pop手势返回冲突的解决办法- (BOOL)gestureRecognizer:(UIGestureRecognizer *)gestureRecognizer shouldRecognizeSimultaneouslyWithGestureRecognizer:(UIGestureRecognizer *)otherGestureRecognizer&#123; // 首先判断otherGestureRecognizer是不是系统pop手势 if ([otherGestureRecognizer.view isKindOfClass:NSClassFromString(@"UILayoutContainerView")]) &#123; // 再判断系统手势的state是began还是fail，同时判断scrollView的位置是不是正好在最左边 if (otherGestureRecognizer.state == UIGestureRecognizerStateBegan &amp;&amp; self.contentOffset.x == 0) &#123; return YES; &#125; &#125; return NO;&#125; 64、设置状态栏方向位置//修改状态栏方向，[UIApplication sharedApplication].statusBarOrientation = UIInterfaceOrientationLandscapeLeft;//枚举值说明：UIDeviceOrientationPortraitUpsideDown, //设备直立，home按钮在上UIDeviceOrientationLandscapeLeft, //设备横置，home按钮在右UIDeviceOrientationLandscapeRight, //设备横置, home按钮在左UIDeviceOrientationFaceUp, //设备平放，屏幕朝上UIDeviceOrientationFaceDown //设备平放，屏幕朝下//再实现这个代理方法就行了- (BOOL)shouldAutorotate&#123; return NO; //必须返回no, 才能强制手动旋转&#125; 65，Git 关联仓库 ,和基本配置-------Git global setup-------git config --global user.name "xinnyu"git config --global user.email "xinnyu007@gmail.com"-------Create a new repository-------git clone git@gitlab.testAddress.com:test/QRZxing.gitcd QRZxingtouch README.mdgit add README.mdgit commit -m "add README"git push -u origin master-------Existing folder or Git repository-------cd existing_foldergit initgit remote add origin git@gitlab.testAddress.com:test/QRZxing.gitgit add .git commitgit push -u origin master 66，Git 命令大全]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Pyinstaller将python脚本打包成可执行文件]]></title>
      <url>%2Farchives%2F2017%2F04%2F14%2FPyinstaller%E5%B0%86python%E8%84%9A%E6%9C%AC%E6%89%93%E5%8C%85%E6%88%90%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6%2F</url>
      <content type="text"><![CDATA[PyInstaller可以用来打包Python应用程序，把Python脚本和所用到的库打包为exe文件，可以更方便的发布程序，避免使用程序的每个电脑都必须安装Python，这样，打包完的程序就可以在没有安装Python解释器的机器上运行了。 安装Pyinstaller使用pip或者easy_install来安装：sudo pip install pyinstaller 使用PyInstallerpyinstaller myapp.py 当使用PyInstaller打包的时候，默认生成一个文件夹，文件夹中包含所有依赖项，以及可执行文件。打包成文件夹的好处就是debug的时候可以清楚的看到依赖项有没有包含。另一个好处是更新的时候，只需要更新可执行文件就可以了。当然缺点也很明显，不方便，不易管理。 那么它是如何工作的呢？PyInstaller的引导程序是一个二进制可执行程序。当用户启动你的程序的时候，PyInstaller的引导程序开始运行，首先创建一个临时的Python环境，然后通过Python解释器导入程序的依赖，当然它们都在同一个文件夹下。 打包成一个文件我们可以用onefile参数将所有文件打包到一个可执行文件中。 pyinstaller --onefile myapp.py 打包成一个文件相对于文件夹更容易管理。坏处运行相对比较慢。这个文件中包含了压缩的依赖文件拷贝（.so文件-Linux，dll文件-Windows）。 当程序运行时，PyInstaller的引导程序会新建一个临时文件夹。然后解压程序的第三方依赖文件到临时文件夹中。这也是为什么一个可执行文件比文件夹中执行的时间要长的原因。剩下的就和上面的一样了。 总结所以，我们要通过PyInstaller生成可执行的文件主要下面两步。 pyinstaller [option] myapp.py option为空生成文件夹，选择onefile，生成一个文件。 如果项目有一些依赖的数据文件，上面生成的二进制文件是无法运行的，这个时候可以通过生成spec文件，而后再用pyinstaller运行spec文件。 pyinstaller [option] myapp.spec 最后有个坑就是目前最新版本的pyinstaller 3.2.1 不支持 python3.6。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Xcode不自动补全问题]]></title>
      <url>%2Farchives%2F2017%2F04%2F13%2FXcode%E4%B8%8D%E8%87%AA%E5%8A%A8%E8%A1%A5%E5%85%A8%E9%97%AE%E9%A2%98%2F</url>
      <content type="text"><![CDATA[1.要import pods里的头文件有时候XCode搜索头文件不会去搜索Pods里的第三方库，我们需要在XCode里设置一下项目Target的Search Paths。 双击User Header Search Paths的空白处，填入”$(PODS_ROOT)”(没有引号), 设置为递归的搜索recursive，问题解决了。 2.XCode自带BUG有些时候我们没有调用第三方库，发现UIkit的自动补全都没法触发了，这样的原因多半是因为XCode自带BUG，在你的注释里有中文的时候，不会触发自动补全，比如这个’年’，删掉过后再编译一下试试，再不行就重启一下XCode。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[基础算法(堆排序)]]></title>
      <url>%2Farchives%2F2017%2F01%2F30%2F%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95(%E5%A0%86%E6%8E%92%E5%BA%8F)%2F</url>
      <content type="text"><![CDATA[堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。 算法步骤 先将初始文件Array[1..n]建成一个大根堆，此堆为初始的无序区。 再将关键字最大的记录Array[1]（即堆顶）和无序区的最后一个记录Array[n]交换，由此得到新的无序区Array[1..n-1]和有序区Array[n]，然后再把无序区建成一个大根堆，然后再次将Array[1..n-1]中关键字最大的记录Array[1]和该区间的最后一个记录Array[n-1]交换. 下面是算法的Swift实现: /// 将Array中的index位置堆化////// - Parameters:/// - array: 数组/// - index: 位置/// - end: 数组的最后位置func maxHeapify(array: inout [Int], index:Int, end:Int)&#123; var parentIndex = index var endIndex = end while true &#123; var leftChildIndex = parentIndex * 2 + 1 var rightChildIndex = leftChildIndex + 1 var childIndex = leftChildIndex if childIndex &gt; endIndex &#123; break &#125; if childIndex + 1 &lt;= endIndex &amp;&amp; array[leftChildIndex] &lt; array[rightChildIndex] &#123; childIndex += 1 &#125; if array[parentIndex] &lt; array[childIndex]&#123; swap(&amp;array[childIndex], &amp;array[parentIndex]) parentIndex = childIndex &#125;else&#123; break &#125; &#125;&#125;/// 创建大根堆func creatMaxHeap(array: inout [Int])&#123; for i in (0...(array.count - 1) / 2).reversed()&#123; maxHeapify(array: &amp;array, index: i, end: array.count - 1) &#125;&#125;/// 堆排序func heapSort(array: inout [Int])&#123; creatMaxHeap(array: &amp;array) for i in (0...array.count - 1).reversed()&#123; if i != 0&#123; swap(&amp;array[0], &amp;array[i]) &#125; maxHeapify(array: &amp;array, index: 0, end: i - 1) &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[基础算法(快速排序)]]></title>
      <url>%2Farchives%2F2017%2F01%2F29%2F%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95(%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F)%2F</url>
      <content type="text"><![CDATA[Quicksort又称划分交换排序，最早由东尼·霍尔提出。在平均状况下，排序n个项目要Ο(n log n)次比较。在最坏状况下则需要Ο(n2)次比较，但这种状况并不常见。事实上，快速排序通常明显比其他Ο(n log n)算法更快，因为它的内部循环（inner loop）可以在大部分的架构上很有效率地被实现出来。 快速排序使用分治法（Divide and conquer）策略来把一个串行（list）分为两个子串行（sub-lists）。 算法步骤 从数列中挑出一个元素，称为 “基准”（pivot）， 重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作。 递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。 递归的最底部情形，是数列的大小是零或一，也就是永远都已经被排序好了。虽然一直递归下去，但是这个算法总会退出，因为在每次的迭代（iteration）中，它至少会把一个元素摆到它最后的位置去。 Swift代码由上面的步骤我们可以写出一个简单的快排算法： func quickSortSimple(array:[Int]) -&gt; [Int]&#123; if array.count &lt;= 1 &#123; return array &#125; var lowArray = [Int](), highArray = [Int]() var pivot = array.first! for i in 1...array.count - 1&#123; let num = array[i] if num &gt; pivot&#123; highArray.append(num) &#125;else&#123; lowArray.append(num) &#125; &#125; var result = quickSortSimple(array: lowArray) result.append(pivot) let highResult = quickSortSimple(array: highArray) result.append(contentsOf: highResult) return result&#125; 上面简单版本有个缺点，就是它需要Ω(n)的额外存储空间。额外需要的存储器空间配置，在实际上的实现，也会极度影响速度和缓存的性能。有一个比较复杂使用原地（in-place）分区算法的版本如下: //用于将func partition(a: inout [Int],low:Int,high:Int) -&gt; Int&#123; if low &gt;= high&#123; return low &#125; let pivot = a[low] var i = low, j = high while i &lt; j &#123; while i &lt; j &amp;&amp; a[j] &gt;= pivot &#123; j -= 1 &#125; while i &lt; j &amp;&amp; a[i] &lt;= pivot &#123; i += 1 &#125; if i &lt; j &#123; swap(&amp;a[i], &amp;a[j]) &#125; &#125; if i != low&#123; swap(&amp;a[i], &amp;a[low]) &#125; return i&#125;func quickSort(array: inout [Int], low:Int, high:Int)&#123; if low &gt; high&#123; return &#125; let index = partition(a: &amp;array, low: low, high: high) quickSort(array: &amp;array, low: low, high: index - 1) quickSort(array: &amp;array, low: index + 1, high: high)&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[iOS,Mac著名开发者博客]]></title>
      <url>%2Farchives%2F2016%2F12%2F24%2FiOS%2CMac%E8%91%97%E5%90%8D%E5%BC%80%E5%8F%91%E8%80%85%E5%8D%9A%E5%AE%A2%2F</url>
      <content type="text"><![CDATA[博客地址 RSS地址 OneV’s Den http://onevcat.com/atom.xml 一只魔法师的工坊 http://blog.ibireme.com/feed/ 破船之家 http://beyondvincent.com/atom.xml NSHipster http://nshipster.cn/feed.xml Limboy 无网不剩 http://feeds.feedburner.com/lzyy 唐巧的技术博客 http://blog.devtang.com/atom.xml Ted’s Homepage http://wufawei.com/feed sunnyxx的技术博客 http://blog.sunnyxx.com/atom.xml Kevin Blog http://zhowkev.in/rss 阿毛的蛋疼地 http://www.xiangwangfeng.com/atom.xml 亚庆的 Blog http://billwang1990.github.io/atom.xml Nonomori http://nonomori.farbox.com/feed Wonderffee’s Blog http://wonderffee.github.io/atom.xml I’m TualatriX http://imtx.me/feed/latest/ Cocoabit http://blog.cocoabit.com/rss/ 不会开机的男孩 http://studentdeng.github.io/atom.xml Nico http://blog.inico.me/atom.xml 阿峰的技术窝窝 http://hufeng825.github.io/atom.xml answer_huang http://answerhuang.duapp.com/index.php/feed/ webfrogs http://blog.nswebfrog.com/feed/ 代码手工艺人 http://joeyio.com/atom.xml Lancy’s Blog http://gracelancy.com/atom.xml I’m Allen http://www.imallen.com/atom.xml Travis’ Blog http://imi.im/feed 王中周的技术博客 http://wangzz.github.io/atom.xml 克伟的博客 http://feed.cnblogs.com/blog/u/23857/rss 摇滚诗人 http://feed.cnblogs.com/blog/u/35410/rss Luke’s Homepage http://geeklu.com/feed/ 萧宸宇 http://iiiyu.com/atom.xml Yuan博客 http://www.heyuan110.com/?feed=rss2 KooFrank’s Blog http://koofrank.com/rss hello it works http://helloitworks.com/feed 码农人生 http://msching.github.io/atom.xml 玉令天下的Blog http://yulingtianxia.com/atom.xml 不掏蜂窝的熊 http://www.hotobear.com/?feed=rss2 猫·仁波切 https://andelf.github.io/atom.xml 煲仔饭 http://ivoryxiong.org/feed.xml 里脊串的开发随笔 http://adad184.com/atom.xml Why’s blog - 汪海的实验室 http://blog.callmewhy.com/atom.xml 土土哥的技术Blog http://tutuge.me/atom.xml 庞海礁的个人空间 http://www.olinone.com/?feed=rss2 Casa Taloyum http://casatwy.com/feeds/all.atom.xml Kenshin Cui’s Blog http://www.cnblogs.com/kenshincui/rss 技术哥的博客 http://suenblog.duapp.com/rss/ 老谭笔记 http://www.tanhao.me/atom.xml coderyi http://www.coderyi.com/feed 雷纯锋的技术博客 http://blog.leichunfeng.com/atom.xml 向晨宇的技术博客 http://iosxxx.com/atom.xml]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[iOS AVPlayer 简单封装]]></title>
      <url>%2Farchives%2F2016%2F11%2F15%2FiOS%20AVPlayer%20%E7%AE%80%E5%8D%95%E5%B0%81%E8%A3%85%2F</url>
      <content type="text"><![CDATA[这里给AVPlayer做一个简单封装，可以实现播放本地视频和网络视频。(Swift 3) 代码如下: AVPlayer:处理播放import AVFoundationimport Foundationprotocol VideoPlayerDelegate &#123; func downloadedProgress(progress:Double) func readyToPlay() func didUpdateProgress(progress:Double) func didFinishPlayItem() func didFailPlayToEnd()&#125;let videoContext:UnsafeMutableRawPointer? = nilclass VideoPlayer: NSObject&#123; private var assetPlayer:AVPlayer? private var playerItem:AVPlayerItem? private var urlAsset:AVURLAsset? private var videoOutput:AVPlayerItemVideoOutput? private var assetDuration:Double = 0 private var playerView:PlayerView? private var autoRepeatPlay:Bool = true private var autoPlay:Bool = true var delegate:VideoPlayerDelegate? var playerRate:Float = 1 &#123; didSet &#123; if let player = assetPlayer &#123; player.rate = playerRate &gt; 0 ? playerRate : 0.0 &#125; &#125; &#125; var volume:Float = 1.0 &#123; didSet &#123; if let player = assetPlayer &#123; player.volume = volume &gt; 0 ? volume : 0.0 &#125; &#125; &#125; convenience init(urlAsset:URL, view:PlayerView, startAutoPlay:Bool = true, repeatAfterEnd:Bool = true) &#123; self.init() playerView = view autoPlay = startAutoPlay autoRepeatPlay = repeatAfterEnd if let playView = playerView, let playerLayer = playView.layer as? AVPlayerLayer &#123; playerLayer.videoGravity = AVLayerVideoGravityResizeAspectFill &#125; initialSetupWithURL(url: urlAsset) prepareToPlay() &#125; override init() &#123; super.init() &#125; // MARK: - Public func isPlaying() -&gt; Bool &#123; if let player = assetPlayer &#123; return player.rate &gt; 0 &#125; else &#123; return false &#125; &#125; func seekToPosition(seconds:Float64) &#123; if let player = assetPlayer &#123; pause() if let timeScale = player.currentItem?.asset.duration.timescale &#123; player.seek(to: CMTimeMakeWithSeconds(seconds, timeScale), completionHandler: &#123; (complete) in self.play() &#125;) &#125; &#125; &#125; func pause() &#123; if let player = assetPlayer &#123; player.pause() &#125; &#125; func play() &#123; if let player = assetPlayer &#123; if (player.currentItem?.status == .readyToPlay) &#123; player.play() player.rate = playerRate &#125; &#125; &#125; func cleanUp() &#123; if let item = playerItem &#123; item.removeObserver(self, forKeyPath: "status") item.removeObserver(self, forKeyPath: "loadedTimeRanges") &#125; NotificationCenter.default.removeObserver(self) assetPlayer = nil playerItem = nil urlAsset = nil &#125; // MARK: - Private private func prepareToPlay() &#123; let keys = ["tracks"] if let asset = urlAsset &#123; asset.loadValuesAsynchronously(forKeys: keys, completionHandler: &#123; DispatchQueue.main.async &#123; self.startLoading() &#125; &#125;) &#125; &#125; private func startLoading()&#123; var error:NSError? guard let asset = urlAsset else &#123;return&#125; let status:AVKeyValueStatus = asset.statusOfValue(forKey: "tracks", error: &amp;error) if status == AVKeyValueStatus.loaded &#123; assetDuration = CMTimeGetSeconds(asset.duration) let videoOutputOptions = [kCVPixelBufferPixelFormatTypeKey as String : Int(kCVPixelFormatType_420YpCbCr8BiPlanarVideoRange)] videoOutput = AVPlayerItemVideoOutput(pixelBufferAttributes: videoOutputOptions) playerItem = AVPlayerItem(asset: asset) if let item = playerItem &#123; item.addObserver(self, forKeyPath: "status", options: .initial, context: videoContext) item.addObserver(self, forKeyPath: "loadedTimeRanges", options: [.new, .old], context: videoContext) NotificationCenter.default.addObserver(self, selector: #selector(playerItemDidReachEnd), name: NSNotification.Name.AVPlayerItemDidPlayToEndTime, object: nil) NotificationCenter.default.addObserver(self, selector: #selector(didFailedToPlayToEnd), name: NSNotification.Name.AVPlayerItemFailedToPlayToEndTime, object: nil) if let output = videoOutput &#123; item.add(output) item.audioTimePitchAlgorithm = AVAudioTimePitchAlgorithmVarispeed assetPlayer = AVPlayer(playerItem: item) if let player = assetPlayer &#123; player.rate = playerRate &#125; addPeriodicalObserver() if let playView = playerView, let layer = playView.layer as? AVPlayerLayer &#123; layer.player = assetPlayer print("player created") &#125; &#125; &#125; &#125; &#125; private func addPeriodicalObserver() &#123; let timeInterval = CMTimeMake(1, 1) if let player = assetPlayer &#123; player.addPeriodicTimeObserver(forInterval: timeInterval, queue: DispatchQueue.main, using: &#123; (time) in self.playerDidChangeTime(time: time) &#125;) &#125; &#125; private func playerDidChangeTime(time:CMTime) &#123; if let player = assetPlayer &#123; let timeNow = CMTimeGetSeconds(player.currentTime()) let progress = timeNow / assetDuration delegate?.didUpdateProgress(progress: progress) &#125; &#125; @objc private func playerItemDidReachEnd() &#123; delegate?.didFinishPlayItem() if let player = assetPlayer &#123; player.seek(to: kCMTimeZero) if autoRepeatPlay == true &#123; play() &#125; &#125; &#125; @objc private func didFailedToPlayToEnd() &#123; delegate?.didFailPlayToEnd() &#125; private func playerDidChangeStatus(status:AVPlayerStatus) &#123; if status == .failed &#123; print("Failed to load video") &#125; else if status == .readyToPlay, let player = assetPlayer &#123; volume = player.volume delegate?.readyToPlay() if autoPlay == true &amp;&amp; player.rate == 0.0 &#123; play() &#125; &#125; &#125; private func moviewPlayerLoadedTimeRangeDidUpdated(ranges:Array&lt;NSValue&gt;) &#123; var maximum:TimeInterval = 0 for value in ranges &#123; let range:CMTimeRange = value.timeRangeValue let currentLoadedTimeRange = CMTimeGetSeconds(range.start) + CMTimeGetSeconds(range.duration) if currentLoadedTimeRange &gt; maximum &#123; maximum = currentLoadedTimeRange &#125; &#125; let progress:Double = assetDuration == 0 ? 0.0 : Double(maximum) / assetDuration delegate?.downloadedProgress(progress: progress) &#125; deinit &#123; cleanUp() &#125; private func initialSetupWithURL(url:URL) &#123; let options = [AVURLAssetPreferPreciseDurationAndTimingKey : true] urlAsset = AVURLAsset(url: url, options: options) &#125; // MARK: - Observations override func observeValue(forKeyPath keyPath: String?, of object: Any?, change: [NSKeyValueChangeKey : Any]?, context: UnsafeMutableRawPointer?) &#123; if context == videoContext&#123; if let key = keyPath&#123; if key == "status", let player = assetPlayer&#123; playerDidChangeStatus(status: player.status) &#125;else if key == "loadedTimeRange", let item = playerItem&#123; moviewPlayerLoadedTimeRangeDidUpdated(ranges: item.loadedTimeRanges) &#125; &#125; &#125; &#125; &#125; PlayerView: 播放视频的Viewclass PlayerView: UIView &#123; override class var layerClass: AnyClass &#123; return AVPlayerLayer.self &#125; var player:AVPlayer?&#123; set&#123; if let layer = layer as? AVPlayerLayer&#123; layer.player = player &#125; &#125; get&#123; if let layer = layer as? AVPlayerLayer&#123; return layer.player &#125; return nil &#125; &#125;&#125; 使用：class VideoTableViewCell: UITableViewCell &#123; @IBOutlet weak var playerView: PlayerView! private var videoPlayer:VideoPlayer? var url:URL! override func awakeFromNib() &#123; super.awakeFromNib() // Initialization code &#125; func preparePlayer() &#123; videoPlayer = VideoPlayer(urlAsset: url, view: playerView) &#125; func pause()&#123; videoPlayer?.pause() &#125; func start()&#123; videoPlayer?.play() &#125; func clean()&#123; videoPlayer?.cleanUp() &#125; func isPlaying() -&gt; Bool&#123; return videoPlayer?.isPlaying() ?? false &#125; &#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Swift小Tips]]></title>
      <url>%2Farchives%2F2016%2F10%2F25%2FSwift%E5%B0%8FTips%2F</url>
      <content type="text"><![CDATA[@noescape和@autoclosure@noescape：这个关键字告诉编译器，参数闭包只能在函数内部使用。它不能被赋值给临时变量，不能异步调用，也不能作为未标记为@noescape的参数传递给其他函数。总之您可以放心，它无法在这个函数作用域之外使用。 除了安全性上的保证，swift还会为标记为@noescape的参数做一些优化，闭包内访问类的成员时您还可以省去self.的语法。 @autoclosure：这个关键字将表达式封装成闭包，优点在于延迟了表达式的执行，缺点是如果滥用会导致代码可读性降低。 swift3中@noescape变成默认了，需要逃离闭包要用到@escape关键字 可变参数func printEverythingWithAKrakenEmojiInBetween(objectsToPrint: Any...) &#123; for object in objectsToPrint &#123; print("\(object)🐙") &#125;&#125;printEverythingWithAKrakenEmojiInBetween("Hey", "Look", "At", "Me", "!") 此时，参数可以当做SequenceType类型来使用，也就是说可以使用for in语法遍历其中的每一个参数。Swift中的print函数就是用这个实现的。 dynamic关键字OC中@dynamic关键字是告诉编译器不要为属性合成getter和setter方法。 Swift中也有dynamic关键字，它可以用于修饰变量或函数，它的意思也与OC完全不同。它告诉编译器使用动态分发而不是静态分发。OC区别于其他语言的一个特点在于它的动态性，任何方法调用实际上都是消息分发，而Swift则尽可能做到静态分发。 因此，标记为dynamic的变量/函数会隐式的加上@objc关键字，它会使用OC的runtime机制。 虽然静态分发在效率上可能更好，不过一些app分析统计的库需要依赖动态分发的特性，动态的添加一些统计代码，这一点在Swift的静态分发机制下很难完成。这种情况下，虽然使用dynamic关键字会牺牲因为使用静态分发而获得的一些性能优化，但也依然是值得的。 特殊的字面量在开发或调试过程中如果能用好下面这四个字面量，将会起到事半功倍的效果： __FILE__：当前代码在那个文件中__FUNCTION__：当前代码在该文件的那个函数中__LINE__：当前代码在该文件的第多少行__COLUMN__：当前代码在改行的多少列 func specialLitertalExpression() &#123; print(__FILE__) print(__FUNCTION__) print(__LINE__) print(__COLUMN__) // 输出结果为11，因为有4个空格，print是五个字符，还有一个左括号。&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[iOS常用宏定义（Siwft篇）]]></title>
      <url>%2Farchives%2F2016%2F10%2F14%2FiOS%E5%B8%B8%E7%94%A8%E5%AE%8F%E5%AE%9A%E4%B9%89%EF%BC%88Swift%E7%AF%87%EF%BC%89%2F</url>
      <content type="text"><![CDATA[swift中并没有宏定义，只是用全局常量和利用函数获取全局常量的方式实现了OC中的宏定义功能。 屏幕let SCREEN_HEIGHT = UIScreen.mainScreen().bounds.heightlet SCREEN_WIDTH = UIScreen.mainScreen().bounds.widthlet FIT_WIDTH = UIScreen.mainScreen().bounds.size.width / 375let FIT_HEIGHT = UIScreen.mainScreen().bounds.size.height / 667 最好的办法是使用结构体： struct ScreenSize &#123; static let height = UIScreen.mainScreen().bounds.height static let width = UIScreen.mainScreen().bounds.width&#125; 系统//系统struct System &#123; static let version = UIDevice .currentDevice().systemVersion&#125; Log/// Logfunc printLog&lt;T&gt;(message: T, file: String = #file, method: String = #function, line: Int = #line)&#123; #if DEBUG print("Log:\((file as NSString).lastPathComponent)[\(line)], \(method): \(message)") #endif&#125;/// Errorfunc printError&lt;T&gt;(message: T, file: String = #file, method: String = #function, line: Int = #line)&#123; #if DEBUG print("Error:\((file as NSString).lastPathComponent)[\(line)], \(method): \(message)") #endif&#125; UIView使用Extension // MARK: - UIView 扩展extension UIView&#123; var x:CGFloat&#123; return frame.origin.x &#125; var y:CGFloat&#123; return frame.origin.y &#125; var width:CGFloat&#123; return frame.size.width &#125; var height:CGFloat&#123; return frame.size.height &#125;&#125; 设备public enum DeviceModel : String &#123; case Simulator = "Simulator/Sandbox", iPod1 = "iPod 1", iPod2 = "iPod 2", iPod3 = "iPod 3", iPod4 = "iPod 4", iPod5 = "iPod 5", iPad2 = "iPad 2", iPad3 = "iPad 3", iPad4 = "iPad 4", iPhone4 = "iPhone 4", iPhone4S = "iPhone 4S", iPhone5 = "iPhone 5", iPhone5S = "iPhone 5S", iPhone5C = "iPhone 5C", iPadMini1 = "iPad Mini 1", iPadMini2 = "iPad Mini 2", iPadMini3 = "iPad Mini 3", iPadAir1 = "iPad Air 1", iPadAir2 = "iPad Air 2", iPhone6 = "iPhone 6", iPhone6plus = "iPhone 6 Plus", iPhone6S = "iPhone 6S", iPhone6Splus = "iPhone 6S Plus", iPhone7 = "iPhone 7", iPhone7plus = "iPhone 7 Plus", Unrecognized = "unrecognized"&#125;extension UIDevice&#123; /// 获取当前设备详细类型 public var deviceModel: DeviceModel&#123; var systemInfo = utsname() uname(&amp;systemInfo) let machineMirror = Mirror(reflecting: systemInfo.machine) let identifier = machineMirror.children.reduce("") &#123; identifier, element in guard let value = element.value as? Int8 , value != 0 else &#123; return identifier &#125; return identifier + String(UnicodeScalar(UInt8(value))) &#125; var modelMap : [ String : DeviceModel ] = [ "i386" : .Simulator, "x86_64" : .Simulator, "iPod1,1" : .iPod1, "iPod2,1" : .iPod2, "iPod3,1" : .iPod3, "iPod4,1" : .iPod4, "iPod5,1" : .iPod5, "iPad2,1" : .iPad2, "iPad2,2" : .iPad2, "iPad2,3" : .iPad2, "iPad2,4" : .iPad2, "iPad2,5" : .iPadMini1, "iPad2,6" : .iPadMini1, "iPad2,7" : .iPadMini1, "iPhone3,1" : .iPhone4, "iPhone3,2" : .iPhone4, "iPhone3,3" : .iPhone4, "iPhone4,1" : .iPhone4S, "iPhone5,1" : .iPhone5, "iPhone5,2" : .iPhone5, "iPhone5,3" : .iPhone5C, "iPhone5,4" : .iPhone5C, "iPad3,1" : .iPad3, "iPad3,2" : .iPad3, "iPad3,3" : .iPad3, "iPad3,4" : .iPad4, "iPad3,5" : .iPad4, "iPad3,6" : .iPad4, "iPhone6,1" : .iPhone5S, "iPhone6,2" : .iPhone5S, "iPad4,1" : .iPadAir1, "iPad4,2" : .iPadAir2, "iPad4,4" : .iPadMini2, "iPad4,5" : .iPadMini2, "iPad4,6" : .iPadMini2, "iPad4,7" : .iPadMini3, "iPad4,8" : .iPadMini3, "iPad4,9" : .iPadMini3, "iPhone7,1" : .iPhone6plus, "iPhone7,2" : .iPhone6, "iPhone8,1" : .iPhone6S, "iPhone8,2" : .iPhone6Splus, "iPhone9,1" : .iPhone7, "iPhone9,2" : .iPhone7plus ] if let model = modelMap[identifier] &#123; return model &#125; return DeviceModel.Unrecognized &#125; /// 判断是不是iPhone var isiPhone:Bool&#123; return model == "iPhone" &#125; /// 判断是不是iPad var isiPad:Bool&#123; return model == "iPad" &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[常用正则表达式]]></title>
      <url>%2Farchives%2F2016%2F10%2F04%2F%E5%B8%B8%E7%94%A8%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
      <content type="text"><![CDATA[下面是开发中经常使用到的正则表达式。 //MARK:- 正则匹配手机号class func checkMobile(_ mobileNumbel:String) -&gt;Bool&#123; let pattern = "^(13[0-9]|15[0-9]|18[0-9]|17[0-9]|147)\\d&#123;8&#125;$" let pred = NSPredicate(format: "SELF MATCHES %@", pattern) let isMatch:Bool = pred.evaluate(with: idCard) return isMatch;&#125;//MARK:- 正则匹配用户身份证号15或18位class func checkUserIdCard(_ idCard:String) -&gt;Bool &#123; let pattern = "(^[0-9]&#123;15&#125;$)|([0-9]&#123;17&#125;([0-9]|X)$)"; let pred = NSPredicate(format: "SELF MATCHES %@", pattern) let isMatch:Bool = pred.evaluate(with: idCard) return isMatch;&#125;//MARK:- 正则匹配用户密码6-18位数字和字母组合class func checkPassword(_ password:String) -&gt;Bool &#123; let pattern = "^(?![0-9]+$)(?![a-zA-Z]+$)[a-zA-Z0-9]&#123;6,18&#125;" let pred = NSPredicate(format: "SELF MATCHES %@", pattern) let isMatch:Bool = pred.evaluate(with: password) return isMatch;&#125;//MARK:- 正则匹配URLclass func checkURL(_ url:String) -&gt;Bool &#123; let pattern = "^[0-9A-Za-z]&#123;1,50&#125;" let pred = NSPredicate(format: "SELF MATCHES %@", pattern) let isMatch:Bool = pred.evaluate(with: url) return isMatch;&#125;//MARK:- 正则匹配用户姓名,20位的中文或英文class func checkUserName(_ userName:String) -&gt;Bool &#123; let pattern = "^[a-zA-Z\\u4E00-\\u9FA5]&#123;1,20&#125;" let pred = NSPredicate(format: "SELF MATCHES %@", pattern) let isMatch:Bool = pred.evaluate(with: userName) return isMatch;&#125;//MARK:- 正则匹配用户emailclass func checkEmail(_ email:String) -&gt;Bool &#123; let pattern = "[A-Z0-9a-z._%+-]+@[A-Za-z0-9.-]+\\.[A-Za-z]&#123;2,4&#125;" let pred = NSPredicate(format: "SELF MATCHES %@", pattern) let isMatch:Bool = pred.evaluate(with: email) return isMatch;&#125;//MARK:- 只能是中文class func isChinese(_ str:String) -&gt;Bool &#123; let pattern = "^[\\u4e00-\\u9fa5]&#123;0,&#125;$" let pred = NSPredicate(format: "SELF MATCHES %@", pattern) let isMatch:Bool = pred.evaluate(with: str) return isMatch;&#125;//MARK:- 正则匹配金额class func checkMoney(_ str:String) -&gt;Bool &#123; let pattern = "^[0-9]+(.[0-9]&#123;2&#125;)?$" let pred = NSPredicate(format: "SELF MATCHES %@", pattern) let isMatch:Bool = pred.evaluate(with: str) return isMatch;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[R.swift使用]]></title>
      <url>%2Farchives%2F2016%2F09%2F14%2FR.swift%E4%BD%BF%E7%94%A8%2F</url>
      <content type="text"><![CDATA[安装使用CocoaPods来对R.Swift进行安装： pod &#39;R.swift&#39; 配置 进入项目的配置界面，在左边的TARGETS项下面选择我们的项目，并在右边点击Build Phases这个tab。 进入&lt;Build Phases&gt;这个tab后，我们看到左上角有一个”+”按钮，点击并在弹出的选项卡中选择New Run Script Phase。 我们会看到界面的下方多出了一个Run Script项，展开它，并在脚本输入区域输入&quot;\$PODS_ROOT/R.swift/rswift&quot; “\$SRCROOT” (第二对双引号括起来所代码的是项目的根目录，你也可以放到根目录下的其他目录中，只需将其修改为”$SRCROOT/XXX”，XXX为目标目录名)。4.我们按住新建的这个Run Script项向上移动，移到Compile Source项的上方，不过也要保证此时它也在Check Pods Manifest.lock项的下方。 Command + B，编译一下，编译成功后，在Finder进入到刚刚我们制定的目录中，此时我们会看到一个名为R.generated.swift的文件已经创建了，直接把此文件拖入Xcode项目中，记住不要勾选Copy items if needed项。 配置到此完成，我们可以构建自己的项目了 使用Image - 图片// 不使用R.Swiftlet pImage = UIImage(named: "image_test")// 使用R.Swiftlet nImage = R.image.image_test() File - 数据文件// 不使用R.Swiftlet pFile = NSBundle.mainBundle().pathForResource("DataFile", ofType: "json")// 使用R.Swiftlet nFile = R.file.dataFileJson.path() Font - 字体// 不使用R.Swiftlet pFont = UIFont(name: "chalkduster", size: 35)// 使用R.Swiftlet nFont = R.font.chalkduster(size: 35)// 你看，非常神奇，在上面的方法中你不仅可以选择字体类型，还能设置字体大小 Color - 颜色把.clr文件拖入项目中即可使用颜色配置let appRedColor = R.color.myAppColor.red() Nibs不使用R.swift let nameOfNib = "CustomView"let customViewNib = UINib(nibName: "CustomView", bundle: nil)let rootViews = customViewNib.instantiate(withOwner: nil, options: nil)let customView = rootViews[0] as? CustomViewlet viewControllerWithNib = CustomViewController(nibName: "CustomView", bundle: nil) 使用 R.swift let nameOfNib = R.nib.customView.namelet customViewNib = R.nib.customView()let rootViews = R.nib.customView.instantiateWithOwner(nil)let customView = R.nib.customView.firstView(owner: nil)let viewControllerWithNib = CustomViewController(nib: R.nib.customView) Localized strings不使用R.swift let welcomeMessage = NSLocalizedString("welcome.message", comment: "")let settingsTitle = NSLocalizedString("title", tableName: "Settings", comment: "")// Formatted stringslet welcomeName = String(format: NSLocalizedString("welcome.withName", comment: ""), locale: NSLocale.current, "Alice")// Stringsdict fileslet progress = String(format: NSLocalizedString("copy.progress", comment: ""), locale: NSLocale.current, 4, 23) 使用 R.swift // Localized strings are grouped per table (.strings file)let welcomeMessage = R.string.localizable.welcomeMessage()let settingsTitle = R.string.settings.title()// Functions with parameters are generated for format stringslet welcomeName = R.string.localizable.welcomeWithName("Alice")// Functions with named argument labels are generated for stringsdict keyslet progress = R.string.localizable.copyProgress(completed: 4, total: 23)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[iOS常用的第三方库]]></title>
      <url>%2Farchives%2F2016%2F09%2F14%2FiOS%E5%B8%B8%E7%94%A8%E7%9A%84%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93%2F</url>
      <content type="text"><![CDATA[DZNEmptyDataSet （空白提示-提升用户体验） github地址 MagicalRecord （数据库-CoreData的封装） github地址 Chameleon (色彩框架） github地址 TextFieldEffects （文本输入框） github地址 Spring （动画框架） github地址 GPUImage (图片处理) github地址 iRate (用户评论) github地址 MGSwipeTableCell (可滑动cell) github地址 FontBlaster （自定义字体加载到APP） github地址 quick (单元测试) github地址 FlatUIKit (扁平化UI的iOS组件) github地址 AlamofireObjectMapper (JSON数据转换成对象) github地址 SnipKit (Masonry Swift版本 自动布局) github地址 Shimmer (有闪烁效果的第三方控件) github地址 RESideMenu (侧滑效果) github地址 RealtimeGradientText (渐变label) github地址 JVFloatLabeledTextField (floating textfield) github地址 SWTableViewCell (滑动Cell) github地址 MonkeyKing （社交分享） github地址 R.swift （以一种优雅安全的方式使用资源文件） github地址 Moya (Alamofire的封装) github地址 SwiftyUserDefaults (UserDefults 封装) github地址 SwiftyUserDefaults 使用 FillableLoaders (自定义的进度加载动画) github地址 SwiftString （字符串扩展） github地址 ExSwift (Swift基础类型扩展库) github地址 Koloda （卡片视图） github地址 ImagePicker （图片选择器） github地址 Material github地址 IFTTT/RazzleDazzle (集成引导页，IFTTT) github地址 Instructions (用法指南，介绍页面) github地址 Animated Tab Bar （动画Tab Bar） github地址 Adaptive Tab Bar github地址 ESTabBarController （Tab Bar） github地址 Eureka (动态TableView) github地址 用法 folding-cell (折叠动画cell) github地址 SCLAlertView (alert view) github地址 SweetAlert-iOS (alert view) github地址 DOFavoriteButton (twitter 风格点赞按钮) github地址 LiquidFloatingActionButton (floating button 动画nice) github地址 ZFRippleButton （Material 风格按钮） github地址 DynamicButton (动态按钮) github地址 paper-switch (改变父视图效果的Switch) github地址 LTMorphingLabel （动画Label） github地址 ActiveLabel.swift （有很多效果的label hashtag） github地址 TextFieldEffects （有很多效果的textfield） github地址 PhoneNumberKit (针对电话输入的textfield) github地址 SkyFloatingLabelTextField （Material 风格textfield） github地址 NextGrowingTextView (自适应高度的TextView) github地址 Hue (颜色 color) github地址 TextAttributes (封装 NSAttributeString) github地址 SwiftOCR github地址 Gifu (GIF) github地址 FlowingMenu (手势侧滑menu) github地址 circle-menu （圆形动画菜单） github地址 PageMenu （分页效果） github地址 XLPagerTabStrip (Material 风格分页效果) github地址 Timepiece （NSDate相关） github地址 Cosmos (评分控件) github地址 ZFPlayer (视频播放) github地址]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[iOS常用宏定义（OC篇）]]></title>
      <url>%2Farchives%2F2016%2F07%2F14%2FiOS%E5%B8%B8%E7%94%A8%E5%AE%8F%E5%AE%9A%E4%B9%89%EF%BC%88OC%E7%AF%87%EF%BC%89%2F</url>
      <content type="text"><![CDATA[OC//获取屏幕宽度和高度#define SCREEN_WIDTH [UIScreen mainScreen].bounds.size.width#define SCREENH_HEIGHT [UIScreen mainScreen].bounds.size.height //支持横屏的宽度和高度#if __IPHONE_OS_VERSION_MAX_ALLOWED &gt;= 80000 // 当前Xcode支持iOS8及以上#define SCREEN_WIDTH ([[UIScreen mainScreen] respondsToSelector:@selector(nativeBounds)]?[UIScreen mainScreen].nativeBounds.size.width/[UIScreen mainScreen].nativeScale:[UIScreen mainScreen].bounds.size.width)#define SCREENH_HEIGHT ([[UIScreen mainScreen] respondsToSelector:@selector(nativeBounds)]?[UIScreen mainScreen].nativeBounds.size.height/[UIScreen mainScreen].nativeScale:[UIScreen mainScreen].bounds.size.height)#define SCREEN_SIZE ([[UIScreen mainScreen] respondsToSelector:@selector(nativeBounds)]?CGSizeMake([UIScreen mainScreen].nativeBounds.size.width/[UIScreen mainScreen].nativeScale,[UIScreen mainScreen].nativeBounds.size.height/[UIScreen mainScreen].nativeScale):[UIScreen mainScreen].bounds.size)#else#define SCREEN_WIDTH [UIScreen mainScreen].bounds.size.width#define SCREENH_HEIGHT [UIScreen mainScreen].bounds.size.height#define SCREEN_SIZE [UIScreen mainScreen].bounds.size#endif//通知中心#define LRNotificationCenter [NSNotificationCenter defaultCenter]//获取随机颜色#define LRRandomColor [UIColor colorWithRed:arc4random_uniform(256)/255.0 green:arc4random_uniform(256)/255.0 blue:arc4random_uniform(256)/255.0 alpha:1.0]//设置RGB颜色#define LRRGBColor(r, g, b) [UIColor colorWithRed:(r)/255.0 green:(g)/255.0 blue:(b)/255.0 alpha:1.0]#define LRRGBAColor(r, g, b, a) [UIColor colorWithRed:(r)/255.0 green:(r)/255.0 blue:(r)/255.0 alpha:a]// clear背景颜色#define LRClearColor [UIColor clearColor]//Log#ifdef DEBUG#define XYLog(...) NSLog(@"%s 第%d行 \n %@\n\n",__func__,__LINE__,[NSString stringWithFormat:__VA_ARGS__])#else#define XYLog(...)#endif//判断是否为iPhone#define IS_IPHONE (UI_USER_INTERFACE_IDIOM() == UIUserInterfaceIdiomPhone)#define IS_IPHONE ([[[UIDevice currentDevice] model] isEqualToString:@"iPhone"])//判断是否为iPad#define IS_IPAD (UI_USER_INTERFACE_IDIOM() == UIUserInterfaceIdiomPad)#define IS_IPAD ([[[UIDevice currentDevice] model] isEqualToString:@"iPad"])//判断是否为ipod#define IS_IPOD ([[[UIDevice currentDevice] model] isEqualToString:@"iPod touch"])// 判断是否为 iPhone 5SE#define iPhone5SE [[UIScreen mainScreen] bounds].size.width == 320.0f &amp;&amp; [[UIScreen mainScreen] bounds].size.height == 568.0f// 判断是否为iPhone 6/6s#define iPhone6_6s [[UIScreen mainScreen] bounds].size.width == 375.0f &amp;&amp; [[UIScreen mainScreen] bounds].size.height == 667.0f// 判断是否为iPhone 6Plus/6sPlus#define iPhone6Plus_6sPlus [[UIScreen mainScreen] bounds].size.width == 414.0f &amp;&amp; [[UIScreen mainScreen] bounds].size.height == 736.0f//获取系统版本#define IOS_SYSTEM_STRING [[UIDevice currentDevice] systemVersion]//判断 iOS 8 或更高的系统版本#define IOS_VERSION_8_OR_LATER (([[[UIDevice currentDevice] systemVersion] floatValue] &gt;=8.0)? (YES):(NO))// 判断是不是iOS系统，如果是iOS系统在真机和模拟器输出都是YES#if TARGET_OS_IPHONE #endif #if (TARGET_IPHONE_SIMULATOR) // 在模拟器的情况下#else // 在真机情况下#endif//获取temp#define kPathTemp NSTemporaryDirectory()//获取沙盒 Document#define kPathDocument [NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES) firstObject]//获取沙盒 Cache#define kPathCache [NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES) firstObject]]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[使用AlamofireObjectMapper]]></title>
      <url>%2Farchives%2F2016%2F02%2F14%2F%E4%BD%BF%E7%94%A8AlamofireObjectMapper%2F</url>
      <content type="text"><![CDATA[通常网络请求返回的是JSON数据，使用ObjectMapper可以让JSON数据直接转化为对象，而使用Alamofire进行网络请求时，使用AlamofireObjectMapper可以直接返回对象，更加简洁。 ###CocoaPods 导入AlamofireObjectMapper'AlamofireObjectMapper', '~> 3.0'```这里采用的Alamofire的测试接口 https://httpbin.org/get在浏览器中打开可以看到JSON格式的数据：```JSON&#123; &quot;args&quot;: &#123;&#125;, &quot;headers&quot;: &#123; &quot;Accept&quot;: &quot;text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8&quot;, &quot;Accept-Encoding&quot;: &quot;gzip, deflate, br&quot;, &quot;Accept-Language&quot;: &quot;zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3&quot;, &quot;Cache-Control&quot;: &quot;max-age=0&quot;, &quot;Host&quot;: &quot;httpbin.org&quot;, &quot;User-Agent&quot;: &quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10.11; rv:46.0) Gecko/20100101 Firefox/46.0&quot; &#125;, &quot;origin&quot;: &quot;202.115.52.218&quot;, &quot;url&quot;: &quot;https://httpbin.org/get&quot;&#125; 根据该JSON的数据格式创建以下两个Mapper类分别对应整个字典和key值为“header”的字典。将JSON中的数据与对象中的数据一一建立转化关系。 import Foundationimport ObjectMapperclass ResponseHeader: Mappable &#123; var accept : String? var acceptEncoding : String? var acceptLanguage : String? var cacheControl : String? var host : String? var userAgent : String? required init?(_ map: Map) &#123; &#125; //映射heades字典中的所有键值 func mapping(map: Map) &#123; accept &lt;- map["Accept"] acceptEncoding &lt;- map["Accept-Encoding"] acceptLanguage &lt;- map["Accept-Language"] cacheControl &lt;- map["Cache-Control"] host &lt;- map["Host"] userAgent &lt;- map["User-Agent"] &#125;&#125; import Foundationimport ObjectMapperclass MyResponse: Mappable &#123; var args : NSDictionary? var headers : ResponseHeader? var origin : String? var url : String? required init?(_ map: Map) &#123; &#125; //映射字典中的所有键值 func mapping(map: Map) &#123; args &lt;- map["args"] headers &lt;- map["headers"] origin &lt;- map["origin"] url &lt;- map["url"] &#125;&#125; 用Alamofire获取对象 func webRequst() &#123; let url = "https://httpbin.org/get" //注意返回的类型为&lt;Mappable对象,NSError&gt; Alamofire.request(.GET, url).responseObject &#123; (response: Response&lt;MyResponse, NSError&gt;) in let myResponse = response.result.value print(myResponse?.url) if let header = myResponse?.headers&#123; print(header.userAgent) &#125; &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Swift 中泛型的使用]]></title>
      <url>%2Farchives%2F2015%2F10%2F15%2FSwift-%E4%B8%AD%E6%B3%9B%E5%9E%8B%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
      <content type="text"><![CDATA[对于类型安全(type-safe)语言，一个常见的问题就是如何编写适用于多种类型输入的程序。想象一下，两个整型数相加和两个浮点数相加的程序看起来应该非常类似，甚至一模一样才对。唯一的区别就是变量的类型不同。 在强类型语言中，你需要去定义诸如addInts, addFloats, addDoubles 等方法来正确地处理参数及返回值。 许多编程语言已经解决了这个问题。例如，在C++中，使用Template来解决。而Swift，Java和C#则采用了泛型来解决这个问题。 下面用有序字典（Ordered Dictionaries）来简单说明一下泛型的用法： 和数组不同的是，包括Swift在内地很多编程语言和框架都不保证集合(sets)和字典(dictionaries)的数据存储顺序。有序字典和普通的字典类似，不同之处在于它的key是有序的。 创建有序字典点击“文件\新建\文件…”新建一个文件，并选择“IOS\Source\Swift File”。点击“下一步”并把这个文件命名为“OrderedDictionary”。最后，点击“创建”。 你会得到一个空的Swift文件，加这样一段代码进去： struct OrderedDictionary &#123; &#125; 到现在为止应该都没有什么问题。通过语义可以看出这个对象是一个结构体。 现在你需要将其一般化，以便它能够装载你需要的任何类型的数据。通过下列改变你对Swift中“结构”的定义： struct OrderedDictionary&lt;KeyType, ValueType&gt; 在尖括弧中的元素是通用类型的参数。KeyType和ValueType不是他们自身的类型，而是你可以使用在结构里定义取代的类型。现在就简洁清新许多了！ 最简单的实现一个有顺序的字典是保持一个数组和一个字典。字典中将会装载衍射，而数组将装载keys的顺序。 在结构体内部的定义中，加入以下的代码： typealias ArrayType = [KeyType]typealias DictionaryType = [KeyType: ValueType]var array = ArrayType()var dictionary = DictionaryType() 这样声明有两个目的，就像上例描述的，有两种类型的用于给已经存在的类型的取新的名称的别名。在这，你将分别地为后面的数组和字典赋值了别名。声明别名是将复杂类型定义为更短名称的类型的一种非常有效的方式。 你将注意怎么样从结构体中定义用“KeyType”和“ValueType”的参数类型中替换类型。上例的”KeyTypes”是数组类型的。当然这是没有这样的类型的“KeyType”；当在一般的实例化时，将替代Swift像对OrderedDictionary的类型的一切类型通过。 就因为这样，你将会注意到编译错误： Type &apos;Keytype&apos; does not conform to protocol &apos;Hashable&apos; 这是因为你的字典Key没有遵循Hashable协议； 我们可以手动修改代码让Key遵循Hashable协议： struct OrderedDictionary&lt;KeyType: Hashable, ValueType 接下来我们就需要正式建立有序字典了； 添加count属性 var count: Int &#123; return self.array.count&#125; 添加插入和移除方法 mutating func removeAtIndex(index: Int) -&gt; (KeyType, ValueType) &#123; precondition(index &lt; self.array.count, "Index 超出范围") assert(index &lt; self.array.count) let key = self.array.removeAtIndex(index) let value = self.dictionary.removeValueForKey(key)! return (key, value)&#125;mutating func insert(value: ValueType, forKey key: KeyType, atIndex index:Int) -&gt; ValueType? &#123; var adjustedIndex = index let existingValue = self.dictionary[key] if existingValue != nil &#123; let existingIndex = self.array.indexOf(key) if existingIndex &lt; index &#123; adjustedIndex-- &#125; self.array.removeAtIndex(existingIndex!) &#125; self.array.insert(key, atIndex: adjustedIndex) self.dictionary[key] = value return existingValue&#125; 注意在结构体内如果方法需要修改结构体内的属性的话，要在方法前加mutating关键字； 添加下标访问方法： subscript(key: KeyType) -&gt; ValueType? &#123; get &#123; return self.dictionary[key] &#125; set &#123; if let _ = self.array.indexOf(key) &#123;&#125;else &#123; self.array.append(key) &#125; self.dictionary[key] = newValue &#125;&#125;subscript(index: Int) -&gt;(KeyType, ValueType) &#123; get &#123; precondition(index &lt; self.array.count, "Index 超出范围") let key = self.array[index] let value = self.dictionary[key]! return (key, value) &#125;&#125; 这样我们就利用泛型创建了一个有序字典。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Swift单例]]></title>
      <url>%2Farchives%2F2015%2F10%2F15%2FSwift%E5%8D%95%E4%BE%8B%2F</url>
      <content type="text"><![CDATA[单例是一个在 Cocoa 中很常用的模式了。对于一些希望能在全局方便访问的实例，或者在 app 的生命周期中只应该存在一个的对象，我们一般使用单例来存储和访问。在 Objective-C 中单例的公认的写法类似下面这样： @implementation MyManager+ (id)sharedManager &#123; static MyManager *staticInstance = nil; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; staticInstance = [[self alloc] init]; &#125;); return staticInstance;&#125;@end 使用 GCD 中的 dispatch_once_t 可以保证里面的代码只被调用一次，以此保证单例在线程上的安全。 因为在 Swift 中可以无缝直接使用 GCD，所以我们可以很方便地把类似方式的单例用 Swift 进行改写： class MyManager &#123; class var sharedManager : MyManager &#123; struct Static &#123; static var onceToken : dispatch_once_t = 0 static var staticInstance : MyManager? = nil &#125; dispatch_once(&amp;Static.onceToken) &#123; Static.staticInstance = MyManager() &#125; return Static.staticInstance! &#125;&#125; 因为 Swift 现在还暂时不支持存储的 class var，所以我们需要使用一个 struct 来存储类型变量。 这样的写法当然没什么问题，但是在 Swift 里我们其实有一个更简单的保证线程安全的方式，那就是 let。把上面的写法简化一下，可以变成： class MyManager &#123; class var sharedManager : MyManager &#123; struct Static &#123; static let sharedInstance : MyManager = MyManager() &#125; return Static.sharedInstance &#125;&#125; 还有另一种更受大家欢迎，并被认为是当前的最佳实践的做法。由于现在 class 不支持存储式的 property，我们想要使用一个只存在一份的属性时，就只能将其定义在全局的 scope 中。值得庆幸的是，在 Swift 拥有访问级别控制后，我们可以在变量定义前面加上 private 关键字，使这个变量只在当前文件中可以被访问。这样我们就可以写出一个没有嵌套的，语法上也更简单好看的单例了： private let sharedInstance = MyManager()class MyManager &#123; class var sharedManager : MyManager &#123; return sharedInstance &#125;&#125; 最后一种是最简单也是最实用的，是swift给的语法糖]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[CocoaPods Podfile]]></title>
      <url>%2Farchives%2F2015%2F10%2F14%2FCocoaPods%20Podfile%2F</url>
      <content type="text"><![CDATA[什么是PodfilePodfile是一个规范，描述了一个或多个一套工程目标的依赖项 一个简单写法:target &apos;MyApp&apos; do pod &apos;AFNetworking&apos;, &apos;~&gt; 3.0&apos;end 更复杂的一个例子：# 下面两行是指明依赖库的来源地址source &apos;https://github.com/CocoaPods/Specs.git&apos;source &apos;https://github.com/Artsy/Specs.git&apos;# 说明平台是ios，版本是9.0platform :ios, &apos;9.0&apos;# 忽略引入库的所有警告（强迫症者的福音啊）inhibit_all_warnings!# 针对MyApp target引入AFNetworking# 针对MyAppTests target引入OCMock，target &apos;MyApp&apos; do pod &apos;AFNetworking&apos;, &apos;~&gt; 3.0&apos; target &apos;MyAppTests&apos; do inherit! :search_paths pod &apos;OCMock&apos;, &apos;~&gt; 2.0.1&apos; endend# 这个是cocoapods的一些配置,官网并没有太详细的说明,一般采取默认就好了,也就是不写.post_install do |installer| installer.pods_project.targets.each do |target| puts target.name endend From a podspec in the root of a library repository (引用仓库根目录的podspec)有时我们需要引入依赖库指定的分支或节点，写法如下。 引入master分支（默认） 'AFNetworking', :git => 'https://github.com/gowalla/AFNetworking.git'```* 引入指定的分支 ```pod &apos;AFNetworking&apos;, :git =&gt; &apos;https://github.com/gowalla/AFNetworking.git&apos;, :branch =&gt; &apos;dev&apos; 引入某个节点的代码 'AFNetworking', :git => 'https://github.com/gowalla/AFNetworking.git', :tag => '0.7.0'```* 引入某个特殊的提交节点 ```pod &apos;AFNetworking&apos;, :git =&gt; &apos;https://github.com/gowalla/AFNetworking.git&apos;, :commit =&gt; &apos;082f8319af&apos; 需要特别注意的是，虽然这样将会满足任何在Pod中的依赖项通过其他Pods 但是podspec必须存在于仓库的根目录中。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[CocoaPods Podfile]]></title>
      <url>%2Farchives%2F2015%2F09%2F29%2FCocoaPods%20Podfile%20(2)%2F</url>
      <content type="text"><![CDATA[什么是PodfilePodfile是一个规范，描述了一个或多个一套工程目标的依赖项 一个简单写法: target 'MyApp' do pod 'AFNetworking', '~&gt; 3.0'end 更复杂的一个例子： # 下面两行是指明依赖库的来源地址source 'https://github.com/CocoaPods/Specs.git'source 'https://github.com/Artsy/Specs.git'# 说明平台是ios，版本是9.0platform :ios, '9.0'# 忽略引入库的所有警告（强迫症者的福音啊）inhibit_all_warnings!# 针对MyApp target引入AFNetworking# 针对MyAppTests target引入OCMock，target 'MyApp' do pod 'AFNetworking', '~&gt; 3.0' target 'MyAppTests' do inherit! :search_paths pod 'OCMock', '~&gt; 2.0.1' endend# 这个是cocoapods的一些配置,官网并没有太详细的说明,一般采取默认就好了,也就是不写.post_install do |installer| installer.pods_project.targets.each do |target| puts target.name endend From a podspec in the root of a library repository (引用仓库根目录的podspec)有时我们需要引入依赖库指定的分支或节点，写法如下。 引入master分支（默认） pod &#39;AFNetworking&#39;, :git =&gt; &#39;https://github.com/gowalla/AFNetworking.git&#39; 引入指定的分支 pod &#39;AFNetworking&#39;, :git =&gt; &#39;https://github.com/gowalla/AFNetworking.git&#39;, :branch =&gt; &#39;dev&#39; 引入某个节点的代码 pod &#39;AFNetworking&#39;, :git =&gt; &#39;https://github.com/gowalla/AFNetworking.git&#39;, :tag =&gt; &#39;0.7.0&#39; 引入某个特殊的提交节点 pod &#39;AFNetworking&#39;, :git =&gt; &#39;https://github.com/gowalla/AFNetworking.git&#39;, :commit =&gt; &#39;082f8319af&#39; 需要特别注意的是，虽然这样将会满足任何在Pod中的依赖项通过其他Pods 但是podspec必须存在于仓库的根目录中。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[设计模式]]></title>
      <url>%2Farchives%2F2015%2F09%2F29%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F</url>
      <content type="text"><![CDATA[设计模式是为了解决特定问题而出现的； 设计模式的基本原则： 开闭原则模块应该对扩展开放而对修改关闭； 里氏代换原则父类和子类之间的方法可以相互调换，从而方便修改；多态 依赖倒转原则抽象不依赖于细节，细节依赖于抽象； 接口隔离原则尽量保证接口只做必要的事情； 合成/聚合复用 适配器模式比如iOS从网络请求加载数据，更新UI的时候，我们会初始化出一个model，随着后续版本的升级，这个model会持续添加参数，或者减少参数；此时如果我们直接修改这个model的话，那么就要同时修改与这个model相匹配的view，这样就会一只在两者之间修改来修改去，适配器模式就是为了解决这种问题存在的。 如果你运用了适配器模式，那么我们的model不会直接与view接触，它会先和适配器接触，然后再通过适配器去更新UI TODO]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Mac自带Vim7.3不能使用系统剪切板解决方案]]></title>
      <url>%2Farchives%2F2015%2F09%2F26%2FMac%E8%87%AA%E5%B8%A6Vim7-3%E4%B8%8D%E8%83%BD%E4%BD%BF%E7%94%A8%E7%B3%BB%E7%BB%9F%E5%89%AA%E5%88%87%E6%9D%BF%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%2F</url>
      <content type="text"><![CDATA[用了Mac自带的Vim之后发现yy复制的内容和剪切板不同步，谷歌之，找到2种方法： “+y 在 ~/.vimrc 里增加 set clipboard=unnamed 但是完全不起任何作用，经过一番折腾之后才知道是Mac自带的Vim7.3版本不支持使用系统剪切板；于是就安装了MacVim，结果试了之后还是不管用，执行 vim --version | grep clip 结果还是： -clientserver -clipboard +cmdline_compl +cmdline_hist +cmdline_info +comments -xterm_clipboard -xterm_save 原因是就算你安装了MacVim使用了Vim7.4系统自带的Terminal还是会默认使用自带的7.3版本； 所以只要在profile中添加如下语句就可以解决问题了； alias vim="/Applications/MacVim.app/Contents/MacOS/Vim" 之后你在终端使用vim也会调用MacVim中的7.4版本了。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Dynamics动画]]></title>
      <url>%2Farchives%2F2015%2F09%2F26%2FDynamics%E5%8A%A8%E7%94%BB%2F</url>
      <content type="text"><![CDATA[UIKit Dynamics是iOS7中新推出的，可以模拟现实的二维动画效果，开发出逼真的物理动画。 关键类 UIDynamicAnimator：封装了底层的物理引擎，为动力项（UIDynamicItem）提供物理相关的功能和动画； UIDynamicBehavior，动力行为，为动力项提供不同的物理行为； UIDynamicItem，动力项，相当于现实世界中的一个基本物体； 使用方法 创建一个UIDynamicAnimator @property(strong, nonatomic) UIDynamicAnimator *dynamicAnimate;- (UIDynamicAnimator *)dynamicAnimate&#123; if (!_dynamicAnimate) &#123; _dynamicAnimate = [[UIDynamicAnimator alloc] initWithReferenceView:self.gameView]; _dynamicAnimate.delegate = self; &#125; return _dynamicAnimate;&#125; 然后就可以把动力行为加到动画中了 [self.dynamicAnimate addBehavior:_dropItemBehavior];]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[使用融云和LeanCloud 创建一个IM应用]]></title>
      <url>%2Farchives%2F2015%2F09%2F21%2F%E4%BD%BF%E7%94%A8%E8%9E%8D%E4%BA%91%E5%92%8CLeanCloud-%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AAIM%E5%BA%94%E7%94%A8%2F</url>
      <content type="text"><![CDATA[融云 是国内一家专门为APP开发者提供IM服务的公司，利用它提供的SDK可以快速使你的APP集成IM通讯能力。详细的使用方法在它官网的开发文档中有提供，但是不得不吐槽的就是它的开发文档写的实在太乱了让人有种无从下手的感觉，下面简单记录一下使用过程。 导入SDK推荐使用CocoaPods导入： 在Podfile中添加： pod &#39;RongCloudIMKit&#39; 然后执行命令： pod install 获取TokenToken 也叫用户令牌，是 SDK 端用来连接融云服务器的凭证，每个用户连接服务器都需要一个 Token。每次初始化连接服务器时，都需要向服务器提交 Token。获取Token需要注册一个融云的账号，然后新建一个应用，之后在API调试中填写userid（用户唯一标示符）、name（用户昵称）、portraitUri（头像url）就可以获得一个测试用的Token。 初始化和测试连接获得测试用的Token之后就可以利用AppKey（创建应用时融云给你的应用标示符）和Token对应用进行初始化了： //用AppKey初始化 RCIM.sharedRCIM().initWithAppKey("82hegw5uh4r8x") //用Token测试连接RCIM.sharedRCIM().connectWithToken(token, success: &#123; (str:String!) -&gt; Void inprint("连接成功！") //连接成功后设置当前登陆用户信息RCIMClient.sharedRCIMClient().currentUserInfo = RCUserInfo(userId: id, name: name, portrait: avatorURL)//在UserDefaults中保存TokenNSUserDefaults.standardUserDefaults().setObject(token, forKey: "kDeviceToken") //在主线程中调用更新UIdispatch_async(dispatch_get_main_queue(), &#123; () -&gt; Void in&#125;)&#125;,error: &#123; (_) -&gt; Void in print("连接错误！")&#125;)&#123; () -&gt; Void in print("Token不正确！")&#125; 连接成功后启动单聊会话融云在它的SDK中已经集成聊天用户界面，所以我们只要创建一个RCConversationViewController的实例就能使用它提供的用户界面了，同时用户界面也支持自定义，这部分在官网的开发文档中有详细的介绍，这里就不做赘述。需要注意的是：要使用RCConversationViewController，必须给它的几个属性赋值： conversationType：聊天类型，有单聊、群聊等等 self.conversationType = RCConversationType.ConversationType_PRIVATE //这里的PRIVATE是单聊 targetId：聊天目标用户id self.targerId = &quot;&quot; userName:聊天目标用户的昵称 self.userName = &quot;&quot; title:聊天界面显示的标题 self.title = self.userNameRCConversationViewController中还有其他很多的属性可以自定义，比如用户头像形状之类的，这些可以在它的头文件中找到。 测试单聊设置好以上内容之后，单聊的工作就已经做好了，现在我们可以测试单聊的效果，这里由于还没有其他的用户，我们就先和自己聊天来测试一下单聊的效果；把targerId设置成已经登录的id，然后就可以自己和自己聊天了，内部集成的界面还是挺简洁易用的，虽然是自己和自己聊天，但是他也不是在本地操作的，也要经过融云的服务器，所以你把网络断开的情况下是不能发出信息的。到这里单聊已经实现了，但是你会发现聊天界面他是不会显示用户头像的，虽然你在初始化的时候给了一个头像的url，但是他是不会加载出来的，不得不说这一点确实很脑残，主要原因是融云为了安全起见，他的服务器是不会储存用户信息的，在融云那边只有一个Token和userid的对应关系，和你发送给他的好友关系，也就是说你的用户信息需要自己在用一个服务器存起来，然后向融云提供一个用户信息提供者； 设置用户信息提供者要设置用户信息提供者首先要实现RCIMUserInfoDataSource协议，所以我们要在APP启动的时候让Appdelegate实现协议，然后： func getUserInfoWithUserId(userId: String!, completion: ((RCUserInfo!) -&gt; Void)!) &#123; let userInfo = RCUserInfo() userInfo.userId = userId switch userId&#123; case "xxx": userInfo.name = "xxx" userInfo.portraitUri = "http://7xl9qm.com1.z0.glb.clouddn.com/avatar.png" case "x": userInfo.name = "A" userInfo.portraitUri = "http://www4.qqjay.com/u/files/2011/1216/d3302821f418fc5539398cb3ba72cd8c.jpg" case "xxxxx": userInfo.name = "B" userInfo.portraitUri = "http://image.photophoto.cn/nm-6/018/030/0180300244.jpg" case "xxxx": userInfo.name = "C" userInfo.portraitUri = "http://cdn.duitang.com/uploads/item/201407/26/20140726221707_i4ZnL.thumb.224_0.jpeg" default: print("no user") &#125; completion(userInfo)&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[使用AVPlayer 播放在线音频,并实现后台锁屏播放，自动连播]]></title>
      <url>%2Farchives%2F2015%2F09%2F21%2F%E4%BD%BF%E7%94%A8AVPlayer-%E6%92%AD%E6%94%BE%E5%9C%A8%E7%BA%BF%E9%9F%B3%E9%A2%91%2F</url>
      <content type="text"><![CDATA[在iOS开发中，AVAudioPlayer不是不能播放在线音频的，要播放在线音频只能用以下几个方法： AVPlayer MPMoviePlayerController 能实现音乐流播（但是此方法苹果在iOS9中已经不推荐使用了） Audioqueue，Audiostream （太复杂） 第三方库AudioStreamer（只能播放在线音频） 所以用AVPlayer来实现在线音频播放是最好的选择；一下就是利用AVPlayer实现音乐流播并实现后台锁屏播放和设置自动连播的大概步骤： 项目源代码：Swift 2.0 版豆瓣电台 初始化先声明AVplayer和AVPlayerItem的实例： var musicPlayer:AVPlayer!var playerItem:AVPlayerItem? 然后在需要的播放音频的地方给它赋值： self.musicPlayer = AVPlayer()let playerLayer = AVPlayerLayer(player: self.musicPlayer)self.view.layer.addSublayer(playerLayer)let url = NSURL(string: " ")//替换当前的playerItemself.musicPlayer.replaceCurrentItemWithPlayerItem(playerItem)//开始播放self.musicPlayer.play() 以上就是实现播放在线音频的代码，但是如果要实现后台播放和自动连播的话，还要做以下工作： 自动连播//当播放完成了之后发送通知，继续播放NSNotificationCenter.defaultCenter().addObserver(self, selector: "playerItemDidReachEnd:", name: AVPlayerItemDidPlayToEndTimeNotification, object: playerItem)//没有播放完成的通知 NSNotificationCenter.defaultCenter().addObserver(self, selector: "playerItemDidNotReachEnd", name: AVPlayerItemFailedToPlayToEndTimeNotification, object: playerItem)//接受到通知后响应的方法func playerItemDidReachEnd(aNotification:NSNotification)&#123; //自动播放相关&#125;func playerItemDidNotReachEnd(aNotification:NSNotification)&#123; //歌曲没有正常播放到结束&#125; 后台播放 如果是播放本地音频的话，后台播放只要在APP启动时加上： let session = AVAudioSession.sharedInstance()try! session.setCategory(AVAudioSessionCategoryPlayback)try! session.setActive(true) 然后在info.plist文件中添加： &lt;key&gt;UIBackgroundModes&lt;/key&gt;&lt;array&gt;&lt;string&gt;audio&lt;/string&gt;&lt;/array&gt; 即可。 但是如果每一首歌都要请求网络的话，只做上述工作时行不通的，还要在实例化AVPlayer的地方加上： //后台播放var bgTask:UIBackgroundTaskIdentifier = 0if UIApplication.sharedApplication().applicationState == UIApplicationState.Background &#123; self.musicPlayer.play() netMusicIsPlaying = true let app:UIApplication = UIApplication.sharedApplication() let newTask:UIBackgroundTaskIdentifier = app.beginBackgroundTaskWithExpirationHandler(nil)if newTask != UIBackgroundTaskInvalid &#123; app.endBackgroundTask(bgTask) &#125; bgTask = newTask&#125;else&#123; self.musicPlayer.play() netMusicIsPlaying = true isPlayOffline = false&#125; 这样才能实现真正的后台播放。 锁屏界面和控制中心添加详情首先要作以下准备工作 在applicationDidEnterBackground中添加：application.beginReceivingRemoteControlEvents() 在ViewDidAppear中添加： UIApplication.sharedApplication().beginReceivingRemoteControlEvents()self.becomeFirstResponder() 在viewDidDisappear中添加： UIApplication.sharedApplication().endReceivingRemoteControlEvents()self.resignFirstResponder() 重写canBecomeFirstResponder方法 override func canBecomeFirstResponder() -&gt; Bool &#123; return true&#125; 然后把歌曲详情设置到锁屏界面： func configNowPlayingInfoCenter()&#123; if (NSClassFromString("MPNowPlayingInfoCenter") != nil) &#123; //锁屏界面图片的存储方式 let mArt:MPMediaItemArtwork = MPMediaItemArtwork(image: currentSongPic) //锁屏界面信息字典 var dic:[String : AnyObject] = [ MPMediaItemPropertyTitle : currentSongTitle, MPMediaItemPropertyArtist : currentSongArtist, MPMediaItemPropertyArtwork : mArt ] //获取当前播放的时间和歌曲总时长 let time = self.musicPlayer.currentTime() let duration = self.musicPlayer.currentItem!.asset.duration //把信息传递给锁屏界面 dic.updateValue(NSNumber(double: CMTimeGetSeconds(time)), forKey: MPNowPlayingInfoPropertyElapsedPlaybackTime ) dic.updateValue(NSNumber(double: CMTimeGetSeconds(duration)), forKey: MPMediaItemPropertyPlaybackDuration) dic.updateValue(NSNumber(float: 1.0), forKey: MPNowPlayingInfoPropertyPlaybackRate) MPNowPlayingInfoCenter.defaultCenter().nowPlayingInfo = dic &#125;&#125; 再处理锁屏和控制中心点击事件： override func remoteControlReceivedWithEvent(event: UIEvent?) &#123; if event!.type == UIEventType.RemoteControl &#123; if event!.subtype == UIEventSubtype.RemoteControlNextTrack &#123; //下一曲 &#125;else if event!.subtype == UIEventSubtype.RemoteControlPause&#123; //暂停按钮 &#125;else if event!.subtype == UIEventSubtype.RemoteControlPlay&#123; //播放按钮 &#125; &#125;&#125; 利用KVO监视播放器的缓存状态和播放状态//先移除观察者 if self.musicPlayer.currentItem != nil &#123; self.musicPlayer.currentItem?.removeObserver(self, forKeyPath: "status") self.musicPlayer.currentItem?.removeObserver(self, forKeyPath: "loadedTimeRanges")&#125;//添加观察者playerItem.addObserver(self, forKeyPath: "status", options: .New, context: nil)playerItem.addObserver(self, forKeyPath: "loadedTimeRanges", options: .New, context: nil)//播放状态playerItem.addObserver(self, forKeyPath: "status", options: .New, context: nil)//缓存进度playerItem.addObserver(self, forKeyPath: "loadedTimeRanges", options: .New, context: nil)//属性改变了要实现的方法override func observeValueForKeyPath(keyPath: String?, ofObject object: AnyObject?, change: [String : AnyObject]?, context: UnsafeMutablePointer&lt;Void&gt;) &#123; //获取缓存进度 if keyPath == "loadedTimeRanges" &#123; let array = (object as! AVPlayerItem).loadedTimeRanges if let range = array.first &#123; //当前缓存的总时间 let rangeValue = range.CMTimeRangeValue let duration = rangeValue.duration //总时间换算成秒数 let loadTime = CMTimeGetSeconds(duration) &#125;else&#123; //获取当前播放状态 &#125;&#125; 获取到了缓存时间可以判断当前的缓存时间和当前播放时间的值，来判断网络状况，同时也可以在做视频播放器时用来作缓存条。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[SDWebImage使用]]></title>
      <url>%2Farchives%2F2015%2F09%2F20%2FSDWebImage%E4%BD%BF%E7%94%A8%2F</url>
      <content type="text"><![CDATA[SDWebImage是一个著名的第三方库，它的作用是： Asynchronous image downloader with cache support with an UIImageView category.就是一个异步加载图片并且支持缓存的UIImage分类； 使用方法：imageView.sd_setImageWithURL(NSURL(string: ""), placeholderImage: UIImage(named: "placeholder")) 清除缓存： SDImageCache.sharedImageCache().cleanDisk()SDImageCache.sharedImageCache().clearMemory() 这个框架使用简单，然而而其中复杂的实现细节全部隐藏在这行代码之后；这边有一篇它的源代码分析：http://draveness.me/ios-yuan-dai-ma-jie-xi-sdwebimage/]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Facebook 动画库POP使用]]></title>
      <url>%2Farchives%2F2015%2F09%2F20%2FFacebook%20%E5%8A%A8%E7%94%BB%E5%BA%93POP%E4%BD%BF%E7%94%A8%2F</url>
      <content type="text"><![CDATA[POP是Facebook公司的一个开源项目，它是一个完全不同于Core Animation的动画引擎；它在基本的静态动画的基础上增加的弹簧动画与衰减动画 使之能创造出更真实更具物理性的交互动画 POP的API可以快速的与现有的ObjC代码集成并可以作用于任意对象的任意属性，POP是个相当成熟且久经考验的框架，Facebook出品的令人惊叹的Paper应用中的所有动画和效果即出自POP。 使用方式：POP默认支持三种动画 但同时也支持自定义动画 POPBasicAnimation POPSpringAnimation POPDecayAnimation POPCustomAnimation //自定义动画 这里我们只讨论前三种，因为自定义动画还没用过； 代码示例：BasicAnimation let rotation = POPBasicAnimation(propertyNamed: kPOPLayerRotation[^POP动画的参数])rotation.toValue = M_PI * 2rotation.duration = 10rotation.repeatForever = truerotation.timingFunction = CAMediaTimingFunction(name: kCAMediaTimingFunctionLinear) self.layer.pop_addAnimation(rotation, forKey: "旋转") POPBasicAnimation提供四种时间曲线,这个和Core Animation中的是一样的： kCAMediaTimingFunctionLinear kCAMediaTimingFunctionEaseIn kCAMediaTimingFunctionEaseOut kCAMediaTimingFunctionEaseInEaseOut POPSpringAnimation弹性动画 //实例化POPlet scale = POPSpringAnimation(propertyNamed:kPOPViewScaleXY)//设置结束值scale.toValue = NSValue(CGPointMake(2,2))//振幅，范围0-20scale.springBounciness = 20//振动速度,范围0-20scale.springSpeed = 1view.layer.pop_addAnimatiom(scale,foKey:"scale") 弹性动画可配置的属性有： springBounciness:4.0 //[0-20] 弹力 越大则震动幅度越大 springSpeed :12.0 //[0-20] 速度 越大则动画结束越快 dynamicsTension :0 //拉力 下面这三个都跟物理力学模拟相关 数值调整起来很费时，建议就用默认值 dynamicsFriction:0 //摩擦 同上 dynamicsMass :0 //质量 同上 POPDecayAnimation阻尼动画 POPDecayAnimation *anDecay = [POPDecayAnimation animationWithPropertyNamed:kPOPLayerPositionX];anDecay.velocity = @(600);anDecay.beginTime = CACurrentMediaTime() + 1.0f;[self.square pop_addAnimation:anDecay forKey:@"position"]; 注意:这里对POPDecayAnimation设置toValue是没有意义的 会被忽略(因为目的状态是动态计算得到的) POPDecayAnimation可配置的属性与默认值有:deceleration:0.998 //衰减系数(越小则衰减得越快) 注意:POPDecayAnimation也是没有duration字段的 其动画持续时间由velocity与deceleration决定 POP默认支持的动画属性： /** Common CALayer property names. */extern NSString * const kPOPLayerBackgroundColor;extern NSString * const kPOPLayerBounds;extern NSString * const kPOPLayerCornerRadius;extern NSString * const kPOPLayerBorderWidth;extern NSString * const kPOPLayerBorderColor;extern NSString * const kPOPLayerOpacity;extern NSString * const kPOPLayerPosition;extern NSString * const kPOPLayerPositionX;extern NSString * const kPOPLayerPositionY;extern NSString * const kPOPLayerRotation;extern NSString * const kPOPLayerRotationX;extern NSString * const kPOPLayerRotationY;extern NSString * const kPOPLayerScaleX;extern NSString * const kPOPLayerScaleXY;extern NSString * const kPOPLayerScaleY;extern NSString * const kPOPLayerSize;extern NSString * const kPOPLayerSubscaleXY;extern NSString * const kPOPLayerSubtranslationX;extern NSString * const kPOPLayerSubtranslationXY;extern NSString * const kPOPLayerSubtranslationY;extern NSString * const kPOPLayerSubtranslationZ;extern NSString * const kPOPLayerTranslationX;extern NSString * const kPOPLayerTranslationXY;extern NSString * const kPOPLayerTranslationY;extern NSString * const kPOPLayerTranslationZ;extern NSString * const kPOPLayerZPosition;extern NSString * const kPOPLayerShadowColor;extern NSString * const kPOPLayerShadowOffset;extern NSString * const kPOPLayerShadowOpacity;extern NSString * const kPOPLayerShadowRadius;/** Common CAShapeLayer property names. */extern NSString * const kPOPShapeLayerStrokeStart;extern NSString * const kPOPShapeLayerStrokeEnd;extern NSString * const kPOPShapeLayerStrokeColor;extern NSString * const kPOPShapeLayerFillColor;/** Common NSLayoutConstraint property names. */extern NSString * const kPOPLayoutConstraintConstant;#if TARGET_OS_IPHONE/** Common UIView property names. */extern NSString * const kPOPViewAlpha;extern NSString * const kPOPViewBackgroundColor;extern NSString * const kPOPViewBounds;extern NSString * const kPOPViewCenter;extern NSString * const kPOPViewFrame;extern NSString * const kPOPViewScaleX;extern NSString * const kPOPViewScaleXY;extern NSString * const kPOPViewScaleY;extern NSString * const kPOPViewSize;extern NSString * const kPOPViewTintColor;/** Common UIScrollView property names. */extern NSString * const kPOPScrollViewContentOffset;extern NSString * const kPOPScrollViewContentSize;extern NSString * const kPOPScrollViewZoomScale;extern NSString * const kPOPScrollViewContentInset;/** Common UITableView property names. */extern NSString * const kPOPTableViewContentOffset;extern NSString * const kPOPTableViewContentSize;/** Common UICollectionView property names. */extern NSString * const kPOPCollectionViewContentOffset;extern NSString * const kPOPCollectionViewContentSize;/** Common UINavigationBar property names. */extern NSString * const kPOPNavigationBarBarTintColor;/** Common UIToolbar property names. */extern NSString * const kPOPToolbarBarTintColor;/** Common UITabBar property names. */extern NSString * const kPOPTabBarBarTintColor;/** Common UILabel property names. */extern NSString * const kPOPLabelTextColor; 自定义属性：POP默认支持的三种动画都继承自POPPropertyAnimation POPPropertyAnimation中定义了一个叫property的属性( 之前没有用到它是因为POP根据不同的默认动画属性帮你生成了默认的property) 而这个property则是用来驱动POP的动画效果中的重要一环。 POPAnimatableProperty *prop = [POPAnimatableProperty propertyWithName:@"prop" initializer:^(POPMutableAnimatableProperty *prop) &#123; // read value prop.readBlock = ^(id obj, CGFloat values[]) &#123; &#125;; // write value prop.writeBlock = ^(id obj, const CGFloat values[]) &#123; &#125;; // dynamics threshold prop.threshold = 0.01;&#125;]; 其组成就是一个readBlock一个writeBlock和一个threashold readBlock告诉POP当前的属性值 writeBlock中修改变化后的属性值 threashold决定了动画变化间隔的阈值 值越大writeBlock的调用次数越少 POPAnimatableProperty其实是POP中一个比较重要的东西,像上面提到的POP自带的动画属性 查看源代码可以看到也只是POP自动帮你设置好了POPAnimatableProperty而已,其作用就是当动画的某个时间片被触发时,告诉系统如何根据当前时间片做出变化. 下面是一个秒表动画，是利用自定义属性的POP做出来的： POPAnimatableProperty *prop = [POPAnimatableProperty propertyWithName:@"countdown" initializer:^(POPMutableAnimatableProperty *prop) &#123; prop.writeBlock = ^(id obj, const CGFloat values[]) &#123; UILabel *lable = (UILabel*)obj; label.text = [NSString stringWithFormat:@"%02d:%02d:%02d",(int)values[0]/60,(int)values[0]%60,(int)(values[0]*100)%100]; &#125;; // prop.threshold = 0.01f; &#125;]; POPBasicAnimation *anBasic = [POPBasicAnimation linearAnimation]; //秒表当然必须是线性的时间函数 anBasic.property = prop; //自定义属性 anBasic.fromValue = @(0); //从0开始 anBasic.toValue = @(3*60); //180秒 anBasic.duration = 3*60; //持续3分钟 anBasic.beginTime = CACurrentMediaTime() + 1.0f; //延迟1秒开始 [label pop_addAnimation:anBasic forKey:@"countdown"]; 出处：http://adad184.com/2015/03/11/intro-to-pop/]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[SwiftyJSON使用]]></title>
      <url>%2Farchives%2F2015%2F09%2F20%2FSwiftyJSON%E4%BD%BF%E7%94%A8%2F</url>
      <content type="text"><![CDATA[SwiftJSON是用Swift写的一个快速处理JSON数据的第三方库。 使用方法：let json = JSON(data: dataFromNetworking)if let userName = json[&quot;name&quot;].string&#123; //就这么简单取到了。&#125; 中文说明]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[MJRefresh使用]]></title>
      <url>%2Farchives%2F2015%2F09%2F20%2FMJRefresh%E4%BD%BF%E7%94%A8%2F</url>
      <content type="text"><![CDATA[MJRefresh是用法最简单的下拉刷新框架：一行代码搞定 支持 UIScrollView、UITableView、UICollectionView、UIWebView 的刷新 基础用法//设置下拉刷新var MJHeader = MJRefreshNormalHeader(refreshingTarget: self, refreshingAction: "refresh")self.myTabView.header = MJHeader//设置上拉加载var MJFooter = MJRefreshAutoNormalFooter(refreshingTarget: self, refreshingAction: "load")self.myTabView.footer = MJFooterfunc load()&#123; //执行加载动作 self.myTabView.header.endRefreshing()&#125;func refresh()&#123; //执行刷新动作 self.myTabView.footer.endRefreshing()&#125; 高级用法 下拉刷新控件的种类 默认（Normal）：MJRefreshNormalHeader 动图（Gif）：MJRefreshGifHeader 上拉刷新控件的种类 自动刷新（Auto） 默认（Normal）：MJRefreshAutoNormalFooter 动图（Gif）：MJRefreshAutoGifFooter 自动回弹（Back） 默认（Normal）：MJRefreshBackNormalFooter 动图（Gif）：MJRefreshBackGifFooter #### // 设置文字[header setTitle:@"Pull down to refresh" forState:MJRefreshStateIdle];[header setTitle:@"Release to refresh" forState:MJRefreshStatePulling];[header setTitle:@"Loading ..." forState:MJRefreshStateRefreshing];// 设置字体header.stateLabel.font = [UIFont systemFontOfSize:15];header.lastUpdatedTimeLabel.font = [UIFont systemFontOfSize:14];// 设置颜色header.stateLabel.textColor = [UIColor redColor];header.lastUpdatedTimeLabel.textColor = [UIColor blueColor];// 隐藏时间header.lastUpdatedTimeLabel.hidden = YES;// 隐藏状态header.stateLabel.hidden = YES; 下拉加载// 设置回调（一旦进入刷新状态，就调用target的action，也就是调用self的loadMoreData方法）MJRefreshAutoGifFooter *footer = [MJRefreshAutoGifFooter footerWithRefreshingTarget:self refreshingAction:@selector(loadMoreData)];// 设置刷新图片[footer setImages:refreshingImages forState:MJRefreshStateRefreshing];// 隐藏刷新状态的文字footer.refreshingTitleHidden = YES;// 如果没有上面的方法，就用footer.stateLabel.hidden = YES;// 隐藏当前的上拉刷新控件self.tableView.footer.hidden = YES;// 变为没有更多数据的状态[footer noticeNoMoreData];]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Alamofile使用]]></title>
      <url>%2Farchives%2F2015%2F09%2F20%2FAlamofile%E4%BD%BF%E7%94%A8%2F</url>
      <content type="text"><![CDATA[Alamofire 是Swift版的 AFNetworking，是非常方便实用的第三方网络操作框架； 使用方法：Alamofire.request(method: Method, URLString: URLStringConvertible, parameters: [String : AnyObject]?, encoding: ParameterEncoding, headers: [String : String]?).response (options: NSJSONReadingOptions, completionHandler: &#123; (NSURLRequest, NSHTTPURLResponse?, NSData?, NSError?) -&gt; Void in //操作数据&#125;) 但是上面方法中有些参数可以省略，基本用法如下： Alamofire.request(.GET, "URL").responseJSON(options: NSJSONReadingOptions.AllowFragments) &#123; (_, _, json, _) -&gt; Void in //操作数据 &#125; 获取数据的方法 response() responseString(encoding: NSStringEncoding) responseJSON(options: NSJSONReadingOptions) responsePropertyList(options: NSPropertyListReadOptions) HTTP Methodspublic enum Method: String &#123; case OPTIONS = "OPTIONS" case GET = "GET" case HEAD = "HEAD" case POST = "POST" case PUT = "PUT" case PATCH = "PATCH" case DELETE = "DELETE" case TRACE = "TRACE" case CONNECT = "CONNECT"&#125; 请求需要的参数parameters类型是一个字典 [String : AnyObject] let parameters = [ "foo": "bar", "baz": ["a", 1], "qux": ["x": 1 , "y": 2 , "z": 3]]Alamofire.request(.POST, "http://httpbin.org/post", parameters: parameters) 下载文件Alamofire.download(.GET, "http://httpbin.org/stream/100") &#123; temporaryURL, response in let fileManager = NSFileManager.defaultManager() if let directoryURL = fileManager.URLsForDirectory(.DocumentDirectory, inDomains: .UserDomainMask)[0] as? NSURL &#123; let pathComponent = response.suggestedFilename return directoryURL.URLByAppendingPathComponent(pathComponent!) &#125; return temporaryURL&#125; 这些都只是Alamofire的常规使用，更加详细的使用方法其官方网站上有详细描述。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[iOS9 网络https 错误]]></title>
      <url>%2Farchives%2F2015%2F09%2F20%2FiOS9-%E7%BD%91%E7%BB%9Chttps-%E9%94%99%E8%AF%AF%2F</url>
      <content type="text"><![CDATA[在iOS9 中，苹果将原http协议改成了https协议，使用 TLS1.2 SSL加密请求数据。 解决办法： 在info.plist中添加 &lt;key&gt;NSAppTransportSecurity&lt;/key&gt;&lt;dict&gt;&lt;key&gt;NSAllowsArbitraryLoads&lt;/key&gt;&lt;true/&gt;&lt;/dict&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[CocoaPods安装使用方法]]></title>
      <url>%2Farchives%2F2015%2F09%2F20%2FCocoaPods%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%2F</url>
      <content type="text"><![CDATA[安装首先安装好Ruby环境，在终端中输入以下命令： sudo gem install cocoapods 可是在天朝，在终端中敲入这个命令之后，会发现半天没有任何反应。原因无他，因为那堵墙阻挡了cocoapods.org。 我们可以用淘宝的Ruby镜像来访问cocoapods。按照下面的顺序在终端中敲入依次敲入命令： gem sources --remove https://rubygems.org/ 等有反应之后再敲入以下命令: gem sources -a http://ruby.taobao.org/ 为了验证你的Ruby镜像是并且仅是taobao，可以用以下命令查看： gem sources -l 只有在终端中出现下面文字才表明你上面的命令是成功的： CURRENT SOURCES ***http://ruby.taobao.org/ 这时候，再次在终端中运行： sudo gem install cocoapods 等上十几秒钟，CocoaPods就可以在你本地下载并且安装好了，不再需要其他设置。 使用e.g.利用CocaPods安装Alamofire 在终端中进入（cd命令）你项目所在目录，然后在当前目录下，利用vim创建Podfile，运行： vim Podfile 然后在Podfile文件中输入以下文字： source 'https://github.com/CocoaPods/Specs.git'platform :ios, '8.0'use_frameworks!pod 'Alamofire', '~&gt; 2.0' 这段文字可以在Alamofire的GitHub中找到；然后保存退出。vim环境下，保存退出命令是： :wq 然后在终端中的当前项目目录下，运行以下命令： pod install 然后CocoaPods就会帮你做好一切了，使用Alamofire只需要在项目中 import Alamofire； 对了，使用过CocoaPods的项目就不用之前的.xcodeproj文件打开了，而是使用.xcworkspace打开。 在这之后如果你还要添加新的第三方库的话，就只要在已经存在的Podfile中添加相应的代码然后到项目文件夹执行： pod update 快速更新第三方库的方法：在更新时使用如下代码替换之前的 pod update pod update --verbose --no-repo-update]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[iOS MVC 详解]]></title>
      <url>%2Farchives%2F2015%2F09%2F19%2FiOS-MVC-%E8%AF%A6%E8%A7%A3%2F</url>
      <content type="text"><![CDATA[模型-视图-控制器这个模式其实应该叫做MCV，用控制器把model与view隔开才对，也就是model与view互相不知道对方的存在，没有任何瓜葛，他们就像一个团队里吵了架的同事，如果有项目需要他俩来参与，那么最好有第三者来管理他俩之间的沟通与协调。这个第三者就是控制器。既然管理，那么姑且就把这个控制器提做项目经理吧，这样的话让他俩干啥就得干啥。就像斯坦福老头说的视图就是控制器的狗腿子。 让我们来欣赏一下这张图（摘自斯坦福公开课的课件）： 先撇开那些乱七八糟的箭头单看他们之间的分界线，view与controller、model与controller之间的线是虚的，而model与view之间的是双黄线，考过驾照的知道越过这个线意味着什么吧。 控制器与视图之间的大部分连线都可以在Xcode中通过按住ctrl来连接。例如outlet，例如delegate。有了这些连线，他们之间的沟通算是畅通无阻了。 用户在view上的操作可以直接告诉控制器让控制器去响应 view需要的代理也可以指派给控制器让控制器去完成 view需要的数据源也需要控制器来提供 总之，控制器很忙，因为它非常被动。 控制器还需要一个角色的参与：model 顾名思义，模型。我觉得使用asp.net里mvc的domain来描述比较好理解，领域。例如你要开发一个图书管理系统，模型里描绘的就是图书的书名、售价、作者，谁借走了，几号借走的，一切关于这个应用领域的数据。我们可以给模型一个简单的定义：它描述了一个应用所有需要抽象出来的数据结构和这些数据之间的关系，还有他们获取数据需要通过的途径（本地的、远程的）等。有了模型，控制器想啥时候去拿数，想怎么拿都行。 仔细观察上面的图，有控制器到model的箭头，没有model到控制器的箭头。因为模型不需要知道控制器的存在，这样可以减少耦合，提高代码复用可能性。把你定义好的model挪到别的项目中，还可以使用。 但是问题来了，当model数据已经更新了，被修改了，怎么通知相关的控制器？注意model上方有个天线，高端！之所以使用无线的，是因为model不知道更改要发给谁，但是model可以广播，model的观点：谁关心我的更改让谁收听去，我对谁收听了我不感兴趣。 广播的方式有两种：Notification 和 KVO（都是设计模式，本系列接下来会详述） 好了，他们几个之间的关系基本有个概念了。mvc模式就是这样，把原本杂乱无章的类，分为三堆，严格监管，按规则行事。 还是那句话：说到底一切都是为了使类之间的耦合性更松散。好的代码应该对扩展开放，对修改关闭。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[iOS 常用第三方库7(Reachability)]]></title>
      <url>%2Farchives%2F2015%2F08%2F11%2FReachability%20%E4%BD%BF%E7%94%A8%2F</url>
      <content type="text"><![CDATA[Reachability 是一个检测网络状态的框架。开发Web等网络应用程序的时候，需要确认网络环境，连接情况等信息。如果没有处理这些信息的话，是不会通过Apple的审查的。 使用方法：将Reachability.h 和 Reachability.m 拷贝到你的工程中。 然后： var reach:Reachability?func checkNetStatus()&#123; self.reach = Reachability.reachabilityForInternetConnection() // Tell the reachability that we DON'T want to be reachable on 3G/EDGE/CDMA self.reach!.reachableOnWWAN = false if reach?.currentReachabilityStatus() == NetworkStatus.ReachableViaWWAN &#123; self.net = NetState.Mobile &#125; // Here we set up a NSNotification observer. The Reachability that caused the notification // is passed in the object parameter NSNotificationCenter.defaultCenter().addObserver(self, selector: "reachabilityChanged:", name: kReachabilityChangedNotification, object: nil) self.reach!.startNotifier() &#125; func reachabilityChanged(notification: NSNotification)&#123; if self.reach!.isReachableViaWiFi() &#123; print("能访问网络") &#125;else if self.reach!.isReachableViaWWAN()&#123; appDelegate.isCanUseNetWork = true print("正在使用移动网络") &#125;else &#123; print("没有网络!!!") self.net = NetState.None &#125; &#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Mac终端command not found 解决办法]]></title>
      <url>%2Farchives%2F2015%2F07%2F26%2FMac%E7%BB%88%E7%AB%AF%E6%8F%90%E7%A4%BA-command-not-found%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95%2F</url>
      <content type="text"><![CDATA[在bash_profile中添加： export PATH="$PATH:$HOME/.rvm/bin" # Add RVM to PATH for scripting[[ -s "$HOME/.rvm/scripts/rvm" ]] &amp;&amp; source "$HOME/.rvm/scripts/rvm" # Load RVM into a shell session *as a function*]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[PNChart 使用]]></title>
      <url>%2Farchives%2F2015%2F07%2F21%2FPNChart%20%E4%BD%BF%E7%94%A8%2F</url>
      <content type="text"><![CDATA[PNChart 是一个简约，易用的第三方图表库，它支持折线图，柱形图，饼状图和圆形图的绘制； 使用方法 画折线图 func setLineChart()&#123; /// 定义一个lineChart var lineChart = PNLineChart(frame: CGRectMake(0, self.view.frame.height/4, self.view.frame.width, self.view.frame.height/2)) //不要使用下面的方法，Width 不好计算，只设置数据的话宽度会自动设定 //lineChart.setXLabels([&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;D&quot;,&quot;E&quot;,&quot;F&quot;], withWidth: 50) lineChart.xLabels = [&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;D&quot;,&quot;E&quot;,&quot;F&quot;] lineChart.axisColor = UIColor.blackColor() lineChart.showCoordinateAxis = true /// 设置第一根折线 var dataArray = [1,4,9,20,8,9] var lineChartData = PNLineChartData() //lineChartData.lineWidth = 20 lineChartData.itemCount = UInt(dataArray.count) lineChartData.color = UIColor.greenColor() lineChartData.getData = (&#123;(index:UInt) -&gt; PNLineChartDataItem in var y = dataArray[Int(index)] return PNLineChartDataItem(y: CGFloat(y)) &#125;) //为数据源设置Title lineChartData.dataTitle = &quot;Swift&quot; /// 设置第二根折线 var dataArray2 = [5,19,9,3,5] var lineChartData2 = PNLineChartData() //lineChartData.lineWidth = 20 lineChartData2.itemCount = UInt(dataArray2.count) lineChartData2.color = UIColor.redColor() lineChartData2.getData = (&#123;(index:UInt) -&gt; PNLineChartDataItem in var y = dataArray2[Int(index)] return PNLineChartDataItem(y: CGFloat(y)) &#125;) //把折线加入到lineChart中，开始画图 lineChart.chartData = [lineChartData,lineChartData2] lineChart.strokeChart() self.view.addSubview(lineChart) /// 为图表设置标签，****要在画图之后添加**** //为数据源2设置Title lineChartData2.dataTitle = &quot;OC&quot; //选择标签风格 lineChart.legendStyle = PNLegendItemStyle.Serial //获取标签 var legend = lineChart.getLegendWithMaxWidth(self.view.frame.width) //设置标签位置 legend.frame = CGRectMake(50, lineChart.frame.origin.y + lineChart.frame.height + 10 , legend.frame.width, legend.frame.height) self.view.addSubview(legend) lineChart.delegate = self &#125; 画柱形图： func setBarChart()&#123; //直接初始化一个PNBarChart，不要数据源 var barChart = PNBarChart(frame: CGRectMake(0, 200, self.view.frame.width, 350)) barChart.xLabels = [&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;D&quot;,&quot;E&quot;] //barChart.xLabelWidth = 55 barChart.yValues = [1,3,6,-7,15] //显示图表边界 barChart.showChartBorder = true //允许负数 barChart.showLevelLine = false //barChart.strokeColor = UIColor.redColor() barChart.barRadius = 2 //设置文字颜色，**********设置不了************ barChart.labelTextColor = UIColor.redColor() //开始画图 barChart.strokeChart() self.view.add&#125; 画圆形图： func setCircleChart()&#123; //直接初始化一个PNCircleChart ，不要数据源之类的 var circelChart = PNCircleChart(frame: CGRectMake(self.view.frame.width/2 - self.view.frame.width/4, 200, self.view.frame.width/2, 200), total: 100, current: 60, clockwise: false, shadow: true, shadowColor: UIColor.grayColor()) circelChart.current = 60 circelChart.total = 100 //circelChart.strokeColor = UIColor.greenColor() circelChart.strokeChart() self.view.addSubview(circelChart) &#125; 画饼状图： func setPieChart()&#123; //先定义一个PNPieChartDataItem数组，116 202 33 72 114 224 var items = [PNPieChartDataItem(value: 50, color: UIColor(red: 116/255, green: 202/255, blue: 33/255, alpha: 1) , description: &quot;Swift&quot;),PNPieChartDataItem(value: 20, color: UIColor(red: 72/255, green: 114/255, blue: 224/255, alpha: 1) , description: &quot;OC&quot;)] var pieChart = PNPieChart(frame: CGRectMake(self.view.frame.width/2 - self.view.frame.width/3, 200, self.view.frame.width/1.5, 200), items: items) pieChart.descriptionTextFont = UIFont.systemFontOfSize(15) pieChart.strokeChart() self.view.addSubview(pieChart) //选择标签风格 pieChart.legendStyle = PNLegendItemStyle.Serial //获取标签 var legend = pieChart.getLegendWithMaxWidth(self.view.frame.width) //设置标签位置 legend.frame = CGRectMake(50, pieChart.frame.origin.y + pieChart.frame.height + 10, legend.frame.width, legend.frame.height) self.view.addSubview(legend) &#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[iOSDate相关]]></title>
      <url>%2Farchives%2F2015%2F07%2F20%2FiOS%20Date%E7%9B%B8%E5%85%B3%2F</url>
      <content type="text"><![CDATA[时间和字符串的转换 Data智能转换成字符串，即可以显示“刚刚”，“昨天”，“几小时之前等等” public extension Date &#123; //MARK: 根据规则返回对应的字符串 func getTimeString() -&gt; String &#123; if isToday &#123; if minute &lt; 5 &#123; return "刚刚" &#125; else if hour &lt; 1 &#123; return "\(minute)分钟之前" &#125; else &#123; return "\(hour)小时之前" &#125; &#125; else if isYesterday &#123; return "昨天 \(self.yesterdayTimeStr())" &#125; else if isYear &#123; return noYesterdayTimeStr() &#125; else &#123; return yearTimeStr() &#125; &#125; fileprivate var selfDate : Date &#123; return self &#125; /// 距当前有几分钟 var minute : Int &#123; let dateComponent = Calendar.current.dateComponents([.minute], from: selfDate, to: Date()) return dateComponent.minute! &#125; /// 距当前有几小时 var hour : Int &#123; let dateComponent = Calendar.current.dateComponents([.hour], from: selfDate, to: Date()) return dateComponent.hour! &#125; /// 是否是今天 var isToday : Bool &#123; return Calendar.current.isDateInToday(selfDate) &#125; /// 是否是昨天 var isYesterday : Bool &#123; return Calendar.current.isDateInYesterday(selfDate) &#125; /// 是否是今年 var isYear: Bool &#123; let nowComponent = Calendar.current.dateComponents([.year], from: Date()) let component = Calendar.current.dateComponents([.year], from: selfDate) return (nowComponent.year == component.year) &#125; func yesterdayTimeStr() -&gt; String &#123; let format = DateFormatter() format.dateFormat = "HH:mm" return format.string(from: selfDate) &#125; func noYesterdayTimeStr() -&gt; String &#123; let format = DateFormatter() format.dateFormat = "MM-dd HH:mm" return format.string(from: selfDate) &#125; func yearTimeStr() -&gt; String &#123; let format = DateFormatter() format.dateFormat = "yyyy-MM-dd HH:mm" return format.string(from: selfDate) &#125;&#125; 自带的转换方法，显示今天 xx:xx func dateToString(date:Date) -&gt; String&#123; //定义一个日期格式 let dateFormat = DateFormatter() //日期风格 dateFormat.dateStyle = DateFormatter.Style.short //时间风格 dateFormat.timeStyle = DateFormatter.Style.short //设置相对日期 dateFormat.doesRelativeDateFormatting = true dateFormat.timeStyle = DateFormatter.Style.short //日期的地区为中国 dateFormat.locale = Locale(identifier: "zh_cn") let dateStr = dateFormat.string(from: date) return dateStr&#125; 日期之间比较//与otherDate比较，相同返回YESnow.isEqualToDate(tomorrow)//与anotherDate比较，返回较早的那个日期now.earlierDate(tomorrow)//与anotherDate比较，返回较晚的那个日期now.laterDate(tomorrow)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Next手机代码显示不全解决办法]]></title>
      <url>%2Farchives%2F2015%2F07%2F14%2FNext%E6%89%8B%E6%9C%BA%E4%BB%A3%E7%A0%81%E6%98%BE%E7%A4%BA%E4%B8%8D%E5%85%A8%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95%2F</url>
      <content type="text"><![CDATA[修改custom.styl(路径：source/css/_custom) 增加如下代码： .code &#123;padding-left: 20px !important;background-color: black;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[NSTimer相关知识]]></title>
      <url>%2Farchives%2F2015%2F06%2F20%2FNSTimer%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%2F</url>
      <content type="text"><![CDATA[定义一个 NSTimer var timer1:NSTimer! = NSTimer.scheduledTimerWithTimeInterval(1, target: self, selector: "addOneMin:", userInfo: nil, repeats: true)//selector 是一个选择器,需要定义一个函数,当函数需要传参时,函数名后应该加冒号 启动 NSTimer .fire() 暂停 .invalidate()]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[iOS 传值总结]]></title>
      <url>%2Farchives%2F2015%2F04%2F20%2FiOS-%E4%BC%A0%E5%80%BC%E6%80%BB%E7%BB%93%2F</url>
      <content type="text"><![CDATA[iOS中传值的方式主要有以下几种： segue传值 通知传值 代理传值 单例传值 ShareApplication NSUserdefault 如果是A页面传值到B页面，之间有segue连接的话，用属性传值就可以搞定，如果从B页面传值到A页面或者之间没有直接的segue的话，就可以使用代理传值或者单例传值了。 segue传值 segue传值就是利用segue跳转时利用属性进行传值，这边就不做记录了。 通知传值 通知是一个单例类，只存在一个通知实例，一个通知会有一个对应的名字，而这个名字就是对应的观察者的接受通知的索引，每个对象都可以接收到这个广播，但是只有这个通知的名字和观察者的名字相同时，对应的观察者才可以接收到这个广播并处理对应逻辑。 //seletor: 接收到通知后应该做的操作；name：该通知对应的名字//A发送通知NSNotificationCenter.defaultCenter().postNotificationName(&quot;通知名字&quot;, object: self, userInfo: [&quot;key&quot;: value])//B接收通知NSNotificationCenter.defaultCenter().addObserver(self, selector: &quot;接收到通知后要执行的方法:&quot;, name: &quot;通知名字&quot;, object: nil)//同时实现接受通知后要执行的方法func 接收到通知后要执行的方法(aNotification:NSNotification)&#123; //value = aNotification.userInfo[&quot;key&quot;]&#125;B方 移除监听removeObserver (一定要记得)deinit &#123; NSNotificationCenter.defaultCenter().removeObserver(self)&#125; 代理传值 //声明委托protocol passValueDele&#123; func passValue(value:String)&#125;//接受委托，并定义一个委托类的对象：let vc1 = self.storyboard?.instantiateViewControllerWithIdentifier(&quot;detail&quot;) as! ViewControllervc1.delegate1 = selffunc passValue(value:String)&#123; //得到value之后执行操作&#125;//在委托类中声明一个委托变量，并调用方法传值；weak var delegate1:passValueDele? //注意用weak，防止循环引用delegate1?.passValue(&quot;value&quot;) 单例传值 简单来说单例传值就是创建一个类的单例，各个ViewController共享数据。 先创建一个单例： class SingleTonClass: NSObject &#123; var value:String? struct singleTon &#123; static var once_t:dispatch_once_t = 0 static var currentDataSong:CurrentDataSong? &#125; class func shareCurrentDataSong()-&gt;CurrentDataSong&#123; dispatch_once(&amp;singleTon.once_t) &#123; () -&gt; Void in singleTon.SingleTonClass = SingleTonClass() &#125; return singleTon.SingleTonClass! &#125; &#125; 然后在需要传值的ViewController中给单例的属性赋值；这样就可以在需要值的ViewController中得到要传的值了； ShareAppDelegate传值 和单例的原理一样，不过这个单例利用的是AppDelegate； NSUserdefault传值 此方法试用于轻量级的数据转移，就是把需要传的值先存入到NSUserdefault中，然后在需要值的地方从NSUserdefault中取值。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[iOS HUD]]></title>
      <url>%2Farchives%2F2015%2F03%2F20%2FiOS%20HUD%2F</url>
      <content type="text"><![CDATA[GitHub上iOS关于HUD的第三方库实在太多了， 这三个比较常用： ProgressHUD SwiftNotice MBProgressHUD ProgressHUD用法简单，一行代码搞定： #import "ProgressHUD.h"ProgressHUD.show("正在刷新！")ProgressHUD.showError("错误")ProgressHUD.showSuccess("刷新成功！")ProgressHUD.dismiss() 但是可自定义的属性不多； SwiftNotice用法同样简单，还支持顶部通知： noticeTop("") //顶部通知notice("", type: NoticeType, autoClear: true)noticeOnlyText("")successNotice("")errorNotice("") MBProgressHUD[MBProgressHUD showHUDAddedTo:self.view animated:YES];dispatch_async(dispatch_get_global_queue( DISPATCH_QUEUE_PRIORITY_LOW, 0), ^&#123; // Do something... dispatch_async(dispatch_get_main_queue(), ^&#123; [MBProgressHUD hideHUDForView:self.view animated:YES]; &#125;);&#125;); 自定义： MBProgressHUD *hud = [MBProgressHUD showHUDAddedTo:self.view animated:YES];hud.mode = MBProgressHUDModeAnnularDeterminate;hud.labelText = @"Loading";[self doSomethingInBackgroundWithProgressCallback:^(float progress) &#123; hud.progress = progress;&#125; completionCallback:^&#123; [hud hide:YES];&#125;];]]></content>
    </entry>

    
  
  
</search>
